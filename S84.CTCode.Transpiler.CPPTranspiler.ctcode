exdef S84.CTCode.dbnf.ctcode;
exdef S84.CTCode.System.ctcode;
exdef S84.CTCode.Transpiler.StandardStructure.ctcode;
exdef S84.CTCode.Transpiler.StringHelper.ctcode;

class CPPTranspiler implements S84.CTCode.Transpiler.StandardStructure.ctcode.TargetSpecificFunctions {
    S84.CTCode.System.ctcode.System system;
    S84.CTCode.dbnf.ctcode.CTCodeFile c_t_code_file;
    string base_name;

    S84.CTCode.System.ctcode.OutputStream logger;

    S84.CTCode.Transpiler.StringHelper.ctcode.StringHelper string_helper;

    function void Initialize() { myself.string_helper = new S84.CTCode.Transpiler.StringHelper.ctcode.StringHelper; }
    function void SetSystem(S84.CTCode.System.ctcode.System system) { myself.system = system; }
    function void SetCTCodeFile(S84.CTCode.dbnf.ctcode.CTCodeFile c_t_code_file) { myself.c_t_code_file = c_t_code_file; }
    function void SetBaseName(string base_name) { myself.base_name = base_name; }
    function void SetLogger(S84.CTCode.System.ctcode.OutputStream logger) { myself.logger = logger; }

    string[] includes;
    string[] interface_declarations;
    string[] class_declarations;
    string current_interface;
    string[] interface_definitions;
    string current_class;
    string[] class_definitions;
    string[] class_init;
    string[] class_functions;
    string[] class_members;
    string[] function_definitions;

    function int GetBaseIndentation() { return 0; }

    function string GetCallName(string name)
    {
        string value = myself.string_helper.SnakeCaseToCamelCase(name);

        if (myself.string_helper.IsReserved(value)) {
            return Concat("ReservedPrefix", value);
        }

        return value;
    }

    function string GetVariableName(string name)
    {
        string value = myself.string_helper.CamelCaseToSnakeCase(name);

        if (value == "myself") {
            return "this";
        }

        if (myself.string_helper.IsReserved(value)) {
            return Concat("reserved_prefix_", value);
        }

        return value;
    }

    function string GetVariableChain(string[] name_parts) {
        string delimiter = "->";
        string first_name = Element(name_parts, 0);
        string result = myself.GetVariableName(first_name);
        int name_parts_index = 1;

        while (name_parts_index < size(name_parts)) {
            string name = Element(name_parts, name_parts_index);
            result = Concat(Concat(result, delimiter), myself.GetVariableName(name));
            name_parts_index = name_parts_index + 1;
        }

        return result;
    }

    function string ConvertCall(string[] name_chain, string[] parameters) {
        string result = Element(name_chain, 0);
        int name_chain_index = 1;

        while (name_chain_index < Size(name_chain)) {
            string name_part = Element(name_chain, name_chain_index);
            result = Concat(Concat(result, "->"), name_part);
            name_chain_index = name_chain_index + 1;
        }

        result = Concat(result, "(");

        if (Size(parameters) > 0) {
            result = Concat(result, Element(parameters, 0));
            int parameters_index = 1;

            while (parameters_index < Size(parameters)) {
                string parameter = Element(parameters, parameters_index);
                result = Concat(result, ",");
                result = Concat(result, parameter);
                parameters_index = parameters_index + 1;
            }
        }

        result = Concat(result, ")");
        return result;
    }

    function string ConvertAllocate(string type) {
        return Concat(Concat(Concat(Concat("std::shared_ptr<", type), ">(new "), type), "())");
    }

    function string ConvertByte(string high, string low) {
        return Concat(Concat("0x", high), low);
    }

    function string ConvertDecimal(string decimal) {
        return decimal;
    }

    function string ConvertNumber(string number) {
        return number;
    }

    function string ConvertBoolean(string boolean) {
        if (boolean == "true") {
            return "true";
        }

        if (boolean == "false") {
            return "false";
        }

        return "";
    }

    function string ConvertVariable(string variable) {
        return variable;
    }

    function string ConvertString(string literal) {
        return Concat(Concat("std::string(\"", literal), "\")");
    }

    function string UnaryOperator(string op, string r_value) {
        if (op == "!") {
            return Concat("!", r_value);
        }

        return r_value;
    }

    function string BinaryOperator(string op, string r_value_l, string r_value_r) {
        if (op == "+") {
            return Concat(Concat(r_value_l, "+"), r_value_r);
        }

        if (op == "-") {
            return Concat(Concat(r_value_l, "-"), r_value_r);
        }

        if (op == "<=") {
            return Concat(Concat(r_value_l, "<="), r_value_r);
        }

        if (op == ">=") {
            return Concat(Concat(r_value_l, ">="), r_value_r);
        }

        if (op == "==") {
            return Concat(Concat(r_value_l, "=="), r_value_r);
        }

        if (op == "!=") {
            return Concat(Concat(r_value_l, "!="), r_value_r);
        }

        if (op == "<") {
            return Concat(Concat(r_value_l, "<"), r_value_r);
        }

        if (op == ">") {
            return Concat(Concat(r_value_l, ">"), r_value_r);
        }

        if (op == "||") {
            return Concat(Concat(r_value_l, "||"), r_value_r);
        }

        if (op == "&&") {
            return Concat(Concat(r_value_l, "&&"), r_value_r);
        }

        return "";
    }

    function string GetTypeName(string name)
    {
        string value = myself.string_helper.SnakeCaseToCamelCase(name);

        if (myself.string_helper.IsReserved(value)) {
            return Concat("ReservedPrefix", value);
        }

        return value;
    }

    function string GetDimensionalType(string singleton_type, int dimensions) {
        string result = singleton_type;

        while (dimensions > 0) {
            result = Concat(Concat("std::vector<", result), ">");
            dimensions = dimensions - 1;
        }

        return result;
    }

    function string GetMapType(string singleton_type) {
        return Concat(Concat("std::unordered_map<std::string, ", singleton_type), ">");
    }

    function string GetPrimativeType(string c_t_type) {
        if (c_t_type == "int") {
            return "int";
        }

        if (c_t_type == "string") {
            return "std::string";
        }

        if (c_t_type == "bool") {
            return "bool";
        }

        if (c_t_type == "float") {
            return "float";
        }

        if (c_t_type == "void") {
            return "void";
        }

        return "";
    }

    function string GetDefinedType(string c_t_type) {
        return Concat(Concat("OmniPointer<", c_t_type), ">");
    }

    function string GetQualifiedTypeName(string[] name_parts) {
        string delimiter = "::";
        int name_parts_index = Size(name_parts) - 1;
        string type_part = Element(name_parts, name_parts_index);
        string result = myself.GetTypeName(type_part);

        if (name_parts_index > 0) {
            while (name_parts_index > 0) {
                name_parts_index = name_parts_index - 1;
                result = Concat(delimiter, result);
                string name_part = Element(name_parts, name_parts_index);
                result = Concat(myself.string_helper.ToLower(name_part), result);
            }
        }

        return result;
    }

    function void BeginProcessingCTCodeFile() {
        ClearList(myself.includes);
        ClearList(myself.interface_declarations);
        ClearList(myself.class_declarations);
        myself.current_interface = "";
        ClearList(myself.interface_definitions);
        myself.current_class = "";
        ClearList(myself.class_definitions);
        ClearList(myself.class_init);
        ClearList(myself.class_functions);
        ClearList(myself.class_members);
        ClearList(myself.function_definitions);
    }

    function void ProcessExdef(string exdef) {
        Append(myself.includes, Concat("#include \"", Concat(exdef, ".hpp\"")));
    }

    function void ProcessUnmanagedType(string unmanaged_type) {}

    function void BeginProcessingInterface(string interface_name) {
        myself.current_interface = interface_name;
        Append(myself.interface_declarations, Concat(Concat("class ", interface_name), ";"));
        Append(myself.interface_definitions, Concat(Concat("class ", interface_name), " {"));
        Append(myself.interface_definitions, "public:");
    }

    function void ProcessInterfaceFunctionDeclaration(string return_type, string function_name, S84.CTCode.Transpiler.StandardStructure.ctcode.ParameterDeclaration[] parameters) {
        Append(myself.interface_definitions, Concat(Concat(Concat(Concat(Concat(Concat(myself.string_helper.Indentation(1), "virtual "), return_type), " "), function_name), myself.MakeParametersString(parameters)), " = 0;"));
    }

    function void FinishProcessingInterface(string interface_name) {
        Append(myself.interface_definitions, "};");
        Append(myself.interface_definitions, "");
        myself.current_interface = "";
    }

    function void BeginProcessingClass(string class_name, string implementing) {
        myself.current_class = class_name;
        Append(myself.class_declarations, Concat(Concat("class ", class_name), ";"));

        if (implementing == "") {
            Append(myself.class_definitions, Concat(Concat("class ", class_name), " {"));
        } else {
            Append(myself.class_definitions, Concat(Concat(Concat(Concat("class ", class_name), " : public "), implementing), " {"));
        }


        Append(myself.class_definitions, "public:");
        Append(myself.class_definitions, Concat(Concat(myself.string_helper.Indentation(1), class_name), "();"));
        Append(myself.class_definitions, Concat(Concat(Concat(myself.string_helper.Indentation(1), "inline ~"), class_name), "() {}"));
        Append(myself.class_definitions, "");

        ClearList(myself.class_init);
        ClearList(myself.class_functions);
        ClearList(myself.class_members);

        Append(myself.class_init, Concat(Concat(Concat(class_name, "::"), class_name), "()"));
        Append(myself.class_init, "{");
    }

    function void BeginProcessingClassFunctionDefinition(string return_type, string function_name, S84.CTCode.Transpiler.StandardStructure.ctcode.ParameterDeclaration[] parameters) {
        Append(myself.class_definitions, Concat(Concat(Concat(Concat(Concat(myself.string_helper.Indentation(1), return_type), " "), function_name), myself.MakeParametersString(parameters)), ";"));
        Append(myself.class_functions, Concat(Concat(Concat(Concat(Concat(return_type, " "), myself.current_class), "::"), function_name), myself.MakeParametersString(parameters)));
    }

    function void BeginProcessCodeBlock(int indent) {
        Append(myself.class_functions, Concat(myself.string_helper.Indentation(indent), "{"));
    }

    function void FinishProcessCodeBlock(int indent) {
        Append(myself.class_functions, Concat(myself.string_helper.Indentation(indent), "}"));
    }

    function void BeginProcessConditional(int indent, string r_value) {
        Append(myself.class_functions, Concat(Concat(Concat(myself.string_helper.Indentation(indent), "if ("), r_value), ")"));
    }

    function void ProcessElse(int indent) {
        Append(myself.class_functions, Concat(myself.string_helper.Indentation(indent), "else"));
    }

    function void FinishProcessConditional(int indent, string r_value) {}

    function void BeginProcessLoop(int indent, string r_value) {
        Append(myself.class_functions, Concat(Concat(Concat(myself.string_helper.Indentation(indent), "while ("), r_value), ")"));
    }

    function void FinishProcessLoop(int indent, string r_value) {}

    function void ProcessRtn(int indent, string r_value) {
        Append(myself.class_functions, Concat(Concat(Concat(myself.string_helper.Indentation(indent), "return "), r_value), ";"));
    }

    function void ProcessDeclaration(int indent, string type, string l_value, string r_value) {
        if (r_value == "") {
            r_value = myself.GetDefault(type);
        }

        if (r_value == "") {
            Append(myself.class_functions, Concat(Concat(Concat(Concat(myself.string_helper.Indentation(indent), type), " "), l_value), ";"));
        } else {
            Append(myself.class_functions, Concat(Concat(Concat(Concat(Concat(Concat(myself.string_helper.Indentation(indent), type), " "), l_value), " = "), r_value), ";"));
        }
    }

    function void ProcessAssignment(int indent, string l_value, string r_value) {
        Append(myself.class_functions, Concat(Concat(Concat(Concat(myself.string_helper.Indentation(indent), l_value), " = "), r_value), ";"));
    }

    function void ProcessCall(int indent, string call) {
        Append(myself.class_functions, Concat(Concat(myself.string_helper.Indentation(indent), call), ";"));
    }

    function void FinishProcessingClassFunctionDefinition(string return_type, string function_name, S84.CTCode.Transpiler.StandardStructure.ctcode.ParameterDeclaration[] parameters) {
        Append(myself.class_functions, "");
    }

    function void ProcessClassMemberDeclaration(string member_type, string member_name) {
        string default_value = myself.GetDefault(member_type);

        if (default_value != "") {
            Append(myself.class_init, Concat(Concat(Concat(Concat(Concat(myself.string_helper.Indentation(1), "this->"), member_name), " = "), default_value), ";"));
        } else {
            Append(myself.class_init, Concat(Concat(Concat(Concat(Concat(myself.string_helper.Indentation(1), "/*this->"), member_name), " = "), "NO_DEFAULT"), ";*/"));
        }

        Append(myself.class_members, Concat(Concat(Concat(Concat(myself.string_helper.Indentation(1), member_type), " "), member_name), ";"));
    }

    function void FinishProcessingClass(string class_name, string implementing) {
        if (Size(myself.class_members) > 0) {
            Append(myself.class_definitions, "");
            Append(myself.class_definitions, "private:");

            int class_members_index = 0;

            while (class_members_index < Size(myself.class_members)) {
                string line = Element(myself.class_members, class_members_index);
                Append(myself.class_definitions, line);
                class_members_index = class_members_index + 1;
            }
        }

        Append(myself.class_definitions, "};");
        Append(myself.class_definitions, "");

        Append(myself.class_init, "}");
        Append(myself.class_init, "");

        int class_init_index = 0;

        while (class_init_index < Size(myself.class_init)) {
            string line = Element(myself.class_init, class_init_index);
            Append(myself.function_definitions, line);
            class_init_index = class_init_index + 1;
        }

        int class_functions_index = 0;

        while (class_functions_index < Size(myself.class_functions)) {
            string line = Element(myself.class_functions, class_functions_index);
            Append(myself.function_definitions, line);
            class_functions_index = class_functions_index + 1;
        }

        myself.current_class = "";
    }

    function void WriteCommonFunctions(S84.CTCode.System.ctcode.OutputStream destination) {
        destination.WriteLine("#ifndef CTCODE_COMMON_FUNCTIONS_VERSION_1");
        destination.WriteLine("#define CTCODE_COMMON_FUNCTIONS_VERSION_1");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("class OmniPointer");
        destination.WriteLine("{");
        destination.WriteLine("public:");
        destination.WriteLine("    OmniPointer() { value_raw = NULL; }");
        destination.WriteLine("    OmniPointer(T* value) { value_raw = value; }");
        destination.WriteLine("    template<typename U>");
        destination.WriteLine("    OmniPointer(U* value) { value_raw = value; }");
        destination.WriteLine("    OmniPointer(std::shared_ptr<T> value) { value_raw = NULL; value_shared = value; }");
        destination.WriteLine("    template<typename U>");
        destination.WriteLine("    OmniPointer(std::shared_ptr<U> value) { value_raw = NULL; value_shared = value; }");
        destination.WriteLine("    template<typename U>");
        destination.WriteLine("    OmniPointer(OmniPointer<U> value) { value_raw = value.value_raw; value_shared = value.value_shared; }");
        destination.WriteLine("");
        destination.WriteLine("    operator bool()");
        destination.WriteLine("    {");
        destination.WriteLine("        if (value_raw) return true;");
        destination.WriteLine("        return value_shared.get() != NULL;");
        destination.WriteLine("    }");
        destination.WriteLine("    T& operator*()");
        destination.WriteLine("    {");
        destination.WriteLine("        if (value_raw) return *value_raw;");
        destination.WriteLine("        return *value_shared;");
        destination.WriteLine("    }");
        destination.WriteLine("    T* operator->()");
        destination.WriteLine("    {");
        destination.WriteLine("        if (value_raw) return value_raw;");
        destination.WriteLine("        return value_shared.get();");
        destination.WriteLine("    }");
        destination.WriteLine("    T* raw()");
        destination.WriteLine("    {");
        destination.WriteLine("        if (value_raw) return value_raw;");
        destination.WriteLine("        return value_shared.get();");
        destination.WriteLine("    }");
        destination.WriteLine("");
        destination.WriteLine("    T* value_raw;");
        destination.WriteLine("    std::shared_ptr<T> value_shared;");
        destination.WriteLine("};");
        destination.WriteLine("");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline std::vector<T*> UnwrapOmniList(std::vector<OmniPointer<T>> input) {");
        destination.WriteLine("	std::vector<T*> result;");
        destination.WriteLine("	for (typename std::vector<OmniPointer<T>>::iterator index = input.begin();index != input.end();index++) {");
        destination.WriteLine("		result.push_back(index->raw());");
        destination.WriteLine("	}");
        destination.WriteLine("	return result;");
        destination.WriteLine("};");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline void ClearList(std::vector<T>& input) { input.clear(); };");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline int Size(const std::vector<T>& input) { return input.size(); };");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline T Element(const std::vector<T>& input, int element) { return input.at(element); };");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline void Append(std::vector<T>& input, T element) { input.push_back(element); };");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline void ClearMap(std::unordered_map<std::string, T>& input) { input.clear(); };");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline void SetKV(std::unordered_map<std::string, T>& input, const std::string& key, T element)");
        destination.WriteLine("{");
        destination.WriteLine("    input.erase(key);");
        destination.WriteLine("    input.insert(std::pair<std::string, T>(key, element));");
        destination.WriteLine("}");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline std::vector<std::string> Keys(const std::unordered_map<std::string, T>& input)");
        destination.WriteLine("{");
        destination.WriteLine("    std::vector<std::string> result;");
        destination.WriteLine("    for(typename std::unordered_map<std::string, T>::const_iterator index = input.begin();index != input.end();index++) {");
        destination.WriteLine("        result.push_back(index->first);");
        destination.WriteLine("    }");
        destination.WriteLine("    return result;");
        destination.WriteLine("}");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline bool HasKV(const std::unordered_map<std::string, T>& input, const std::string& key)");
        destination.WriteLine("{");
        destination.WriteLine("    typename std::unordered_map<std::string, T>::const_iterator beginning = input.find(key);");
        destination.WriteLine("    return beginning != input.end();");
        destination.WriteLine("}");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline T GetKV(const std::unordered_map<std::string, T>& input, const std::string& key) { return input.at(key); }");
        destination.WriteLine("inline int Length(const std::string& input) { return (int)input.length(); };");
        destination.WriteLine("inline std::string At(const std::string& input, int index) { return input.substr(index, 1); };");
        destination.WriteLine("inline int IntAt(const std::string& input, int index) { return (input.at(index) + 256) % 256; };");
        destination.WriteLine("inline std::string Concat(const std::string& left, const std::string& right) { return left + right; };");
        destination.WriteLine("#endif");
    }

    function void WriteBeginingGuard(S84.CTCode.System.ctcode.OutputStream file) {
        string guard_name = myself.string_helper.ToUpper(myself.string_helper.StripDot(Concat(myself.base_name, "_H")));
        file.WriteLine(Concat("#ifndef ", guard_name));
        file.WriteLine(Concat("#define ", guard_name));
    }

    function string[] TokenizeBaseName(string name)
    {
        string[] base_name_tokens;
        string current_token = "";
        int index = 0;

        while (index < Length(name)) {
            string character = At(name, index);

            if (character == ".") {
                Append(base_name_tokens, current_token);
                current_token = "";
            } else {
                current_token = Concat(current_token, character);
            }

            index = index + 1;
        }

        Append(base_name_tokens, current_token);
        return base_name_tokens;
    }

    function void WriteBeginingNamespace(S84.CTCode.System.ctcode.OutputStream file) {
        string[] base_name_tokens = myself.TokenizeBaseName(myself.base_name);

        int base_name_tokens_index = 0;

        while (base_name_tokens_index < Size(base_name_tokens)) {
            string base_name_token = Element(base_name_tokens, base_name_tokens_index);
            file.WriteLine(Concat(Concat("namespace ", myself.string_helper.ToLower(base_name_token)), " {"));
            base_name_tokens_index = base_name_tokens_index + 1;
        }
    }

    function void WriteEndingNamespace(S84.CTCode.System.ctcode.OutputStream file) {
        string[] base_name_tokens = myself.TokenizeBaseName(myself.base_name);

        int base_name_tokens_index = 0;

        while (base_name_tokens_index < Size(base_name_tokens)) {
            string base_name_token = Element(base_name_tokens, base_name_tokens_index);
            file.WriteLine("};");
            base_name_tokens_index = base_name_tokens_index + 1;
        }
    }

    function void WriteEndingGuard(S84.CTCode.System.ctcode.OutputStream file) {
        file.WriteLine("#endif");
    }

    function void FinishProcessingCTCodeFile() {
        string header_file_name = Concat(myself.base_name, ".hpp");
        S84.CTCode.System.ctcode.OutputStream header_file = myself.system.OpenFileWriter(header_file_name);
        string source_file_name = Concat(myself.base_name, ".cpp");
        S84.CTCode.System.ctcode.OutputStream source_file = myself.system.OpenFileWriter(source_file_name);
        myself.WriteBeginingGuard(header_file);
        header_file.writeLine("");

        if (Size(myself.includes) > 0) {
            myself.string_helper.WriteLines(header_file, myself.includes);
            header_file.writeLine("");
        }

        header_file.writeLine("#include <cstring>");
        header_file.writeLine("#include <list>");
        header_file.writeLine("#include <unordered_map>");
        header_file.writeLine("#include <memory>");
        header_file.writeLine("#include <string>");
        header_file.writeLine("#include <vector>");
        header_file.writeLine("");

        myself.WriteCommonFunctions(header_file);
        header_file.writeLine("");

        myself.WriteBeginingNamespace(header_file);
        header_file.WriteLine("");

        if (Size(myself.interface_declarations) > 0) {
            myself.string_helper.WriteLines(header_file, myself.interface_declarations);
            header_file.WriteLine("");
        }

        if (Size(myself.class_declarations) > 0) {
            myself.string_helper.WriteLines(header_file, myself.class_declarations);
            header_file.WriteLine("");
        }

        if (Size(myself.interface_definitions) > 0) {
            myself.string_helper.WriteLines(header_file, myself.interface_definitions);
        }

        myself.string_helper.WriteLines(header_file, myself.class_definitions);
        myself.WriteEndingNamespace(header_file);
        header_file.writeLine("");
        myself.WriteEndingGuard(header_file);

        source_file.WriteLine(Concat(Concat("#include \"", myself.base_name), ".hpp\""));
        source_file.WriteLine("");

        myself.WriteBeginingNamespace(source_file);
        source_file.WriteLine("");

        if (Size(myself.function_definitions) > 0) {
            myself.string_helper.WriteLines(source_file, myself.function_definitions);
            source_file.WriteLine("");
        }

        myself.WriteEndingNamespace(source_file);
    }

    function string GetDefault(string cpp_type) {
        if (cpp_type == "int") {
            return "0";
        }

        if (cpp_type == "std::string") {
            return "\"\"";
        }

        if (cpp_type == "bool") {
            return "false";
        }

        if (cpp_type == "float") {
            return "0.0";
        }

        if (cpp_type == "void") {
            return "NULL";
        }

        if (myself.string_helper.BeginsWith("std::unordered_map<std::string, ", cpp_type)) {
            return "";
        }

        if (myself.string_helper.BeginsWith("std::vector<", cpp_type)) {
            return "";
        }

        return "NULL";
    }

    function string MakeParametersString(S84.CTCode.Transpiler.StandardStructure.ctcode.ParameterDeclaration[] parameters) {
        string result = "(";
        int parameters_index = 0;

        while (parameters_index < Size(parameters)) {
            S84.CTCode.Transpiler.StandardStructure.ctcode.ParameterDeclaration parameter = Element(parameters, parameters_index);

            if (parameters_index != 0) {
                result = Concat(result, ", ");
            }

            result = Concat(Concat(Concat(result, parameter.GetType()), " "), parameter.GetName());
            parameters_index = parameters_index + 1;
        }

        result = Concat(result, ")");
        return result;
    }
}