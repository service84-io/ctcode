exdef S84.CTCode.dbnf.ctcode;
exdef S84.CTCode.System.ctcode;
exdef S84.CTCode.Transpiler.ctcode;

class ParameterDeclaration {
    string type;
    string name;

    function string GetType() { return myself.type; }
    function void SetType(string input) { myself.type = input; }
    function string GetName() { return myself.name; }
    function void SetName(string input) { myself.name = input; }
}

class IntegerReference {
    int value;

    function int GetValue() { return myself.value; }
    function void SetValue(int value) { myself.value = value; }
}

class CPPTranspiler implements S84.CTCode.Transpiler.ctcode.Transpiler {
    S84.CTCode.System.ctcode.System system;
    S84.CTCode.dbnf.ctcode.CTCodeFile c_t_code_file;
    string base_name;

    string[][] operator_precedent;

    S84.CTCode.System.ctcode.OutputStream logger;

    string[] includes;
    string[] interface_declarations;
    string[] class_declarations;
    string current_interface;
    string[] interface_definitions;
    string current_class;
    string[] class_definitions;
    string[] class_init;
    string[] class_functions;
    string[] class_members;
    string[] function_definitions;

    /* These target specific functions
     * VVVVVVVV
     * VVVVVVVV
     * VVVVVVVV
     * VVVVVVVV
    */
    function int GetBaseIndentation() { return 0; }

    function string GetCallName(S84.CTCode.dbnf.ctcode.Name name)
    {
        if (name)
        {
            return myself.SnakeCaseToCamelCase(name.UnParse());
        }
        else
        {
            return "";
        }
    }

    function string GetVariableName(S84.CTCode.dbnf.ctcode.Name name)
    {
        if (name)
        {
            string value = myself.CamelCaseToSnakeCase(name.UnParse());

            if (value == "myself") {
                return "this";
            }

            return value;
        }
        else
        {
            return "";
        }
    }

    function string GetVariableChainNameTail(S84.CTCode.dbnf.ctcode.NameTail tail)
    {
        string accessor = "->";

        if (tail)
        {
            return Concat(Concat(accessor, myself.GetVariableName(tail.GetName())), myself.GetVariableChainNameTail(tail.GetTail()));
        }
        else
        {
            return "";
        }
    }

    function string GetVariableChain(S84.CTCode.dbnf.ctcode.QualfiedName l_value)
    {
        if (l_value)
        {
            return Concat(myself.GetVariableName(l_value.GetName()), myself.GetVariableChainNameTail(l_value.GetTail()));
        }
        else
        {
            return "";
        }
    }

    function string ConvertCall(string[] name_chain, string[] parameters) {
        string result = Element(name_chain, 0);
        int name_chain_index = 1;

        while (name_chain_index < Size(name_chain)) {
            string name_part = Element(name_chain, name_chain_index);
            result = Concat(Concat(result, "->"), name_part);
            name_chain_index = name_chain_index + 1;
        }

        result = Concat(result, "(");

        if (Size(parameters) > 0) {
            result = Concat(result, Element(parameters, 0));
            int parameters_index = 1;

            while (parameters_index < Size(parameters)) {
                string parameter = Element(parameters, parameters_index);
                result = Concat(result, ",");
                result = Concat(result, parameter);
                parameters_index = parameters_index + 1;
            }
        }

        result = Concat(result, ")");
        return result;
    }

    function string ConvertAllocate(string type) {
        return Concat(Concat(Concat(Concat("std::shared_ptr<", type), ">(new "), type), "())");
    }

    function string ConvertByte(string high, string low) {
        return Concat(Concat("0x", high), low);
    }

    function string ConvertDecimal(string decimal) {
        return decimal;
    }

    function string ConvertNumber(string number) {
        return number;
    }

    function string ConvertBoolean(string boolean) {
        if (boolean == "true") {
            return "true";
        }

        if (boolean == "false") {
            return "false";
        }

        return "";
    }

    function string ConvertVariable(string variable) {
        return variable;
    }

    function string ConvertString(string literal) {
        return Concat(Concat("std::string(\"", literal), "\")");
    }

    function string UnaryOperator(string op, string r_value) {
        if (op == "!") {
            return Concat("!", r_value);
        }

        return r_value;
    }

    function string BinaryOperator(string op, string r_value_l, string r_value_r) {
        if (op == "+") {
            return Concat(Concat(r_value_l, "+"), r_value_r);
        }

        if (op == "-") {
            return Concat(Concat(r_value_l, "-"), r_value_r);
        }

        if (op == "<=") {
            return Concat(Concat(r_value_l, "<="), r_value_r);
        }

        if (op == ">=") {
            return Concat(Concat(r_value_l, ">="), r_value_r);
        }

        if (op == "==") {
            return Concat(Concat(r_value_l, "=="), r_value_r);
        }

        if (op == "!=") {
            return Concat(Concat(r_value_l, "!="), r_value_r);
        }

        if (op == "<") {
            return Concat(Concat(r_value_l, "<"), r_value_r);
        }

        if (op == ">") {
            return Concat(Concat(r_value_l, ">"), r_value_r);
        }

        if (op == "||") {
            return Concat(Concat(r_value_l, "||"), r_value_r);
        }

        if (op == "&&") {
            return Concat(Concat(r_value_l, "&&"), r_value_r);
        }

        return "";
    }

    function string GetTypeName(S84.CTCode.dbnf.ctcode.Name name)
    {
        if (name)
        {
            return myself.SnakeCaseToCamelCase(name.UnParse());
        }
        else
        {
            return "";
        }
    }

    function string GetDimensionalType(string singleton_type, int dimensions) {
        string result = singleton_type;

        while (dimensions > 0) {
            result = Concat(Concat("std::vector<", result), ">");
            dimensions = dimensions - 1;
        }

        return result;
    }

    function string GetMapType(string singleton_type) {
        return Concat(Concat("std::unordered_map<std::string, ", singleton_type), ">");
    }

    function string GetPrimativeType(string c_t_type) {
        if (c_t_type == "int") {
            return "int";
        }

        if (c_t_type == "string") {
            return "std::string";
        }

        if (c_t_type == "bool") {
            return "bool";
        }

        if (c_t_type == "float") {
            return "float";
        }

        if (c_t_type == "void") {
            return "void";
        }

        return "";
    }

    function string GetQualifiedTypeName(S84.CTCode.dbnf.ctcode.Name[] name_parts) {
        string delimiter = "::";
        int name_parts_index = Size(name_parts) - 1;
        int last_package_index = Size(name_parts) - 2;
        S84.CTCode.dbnf.ctcode.Name type_part = Element(name_parts, name_parts_index);
        string result = myself.GetTypeName(type_part);

        if (name_parts_index > 0) {
            result = Concat(delimiter, result);

            while (name_parts_index > 0) {
                name_parts_index = name_parts_index - 1;
                S84.CTCode.dbnf.ctcode.Name name_part = Element(name_parts, name_parts_index);

                if (name_parts_index != last_package_index) {
                    result = Concat(delimiter, result);
                }

                result = Concat(myself.ToLower(name_part.UnParse()), result);
            }
        }

        return result;
    }

    function void BeginProcessingCTCodeFile() {
        ClearList(myself.includes);
        ClearList(myself.interface_declarations);
        ClearList(myself.class_declarations);
        myself.current_interface = "";
        ClearList(myself.interface_definitions);
        myself.current_class = "";
        ClearList(myself.class_definitions);
        ClearList(myself.class_init);
        ClearList(myself.class_functions);
        ClearList(myself.class_members);
        ClearList(myself.function_definitions);
    }

    function void ProcessExdef(string exdef) {
        Append(myself.includes, Concat("#include \"", Concat(exdef, ".hpp\"")));
    }

    function void ProcessUnmanagedType(string unmanaged_type) {
        int noop = 0;
    }

    function void BeginProcessingInterface(string interface_name) {
        myself.current_interface = interface_name;
        Append(myself.interface_declarations, Concat(Concat("class ", interface_name), ";"));
        Append(myself.interface_definitions, Concat(Concat("class ", interface_name), " {"));
        Append(myself.interface_definitions, "public:");
    }

    function void ProcessInterfaceFunctionDeclaration(string return_type, string function_name, ParameterDeclaration[] parameters) {
        Append(myself.interface_definitions, Concat(Concat(Concat(Concat(Concat(Concat(myself.Indentation(1), "virtual "), return_type), " "), function_name), myself.MakeParametersString(parameters)), " = 0;"));
    }

    function void FinishProcessingInterface(string interface_name) {
        Append(myself.interface_definitions, "};");
        Append(myself.interface_definitions, "");
        myself.current_interface = "";
    }

    function void BeginProcessingClass(string class_name, string implementing) {
        myself.current_class = class_name;
        Append(myself.class_declarations, Concat(Concat("class ", class_name), ";"));

        if (implementing == "") {
            Append(myself.class_definitions, Concat(Concat("class ", class_name), " {"));
        } else {
            Append(myself.class_definitions, Concat(Concat(Concat(Concat("class ", class_name), " : public "), implementing), " {"));
        }


        Append(myself.class_definitions, "public:");
        Append(myself.class_definitions, Concat(Concat(myself.Indentation(1), class_name), "();"));
        Append(myself.class_definitions, Concat(Concat(Concat(myself.Indentation(1), "inline ~"), class_name), "() {}"));
        Append(myself.class_definitions, "");

        ClearList(myself.class_init);
        ClearList(myself.class_functions);
        ClearList(myself.class_members);

        Append(myself.class_init, Concat(Concat(Concat(class_name, "::"), class_name), "()"));
        Append(myself.class_init, "{");
    }

    function void BeginProcessingClassFunctionDefinition(string return_type, string function_name, ParameterDeclaration[] parameters) {
        Append(myself.class_definitions, Concat(Concat(Concat(Concat(Concat(myself.Indentation(1), return_type), " "), function_name), myself.MakeParametersString(parameters)), ";"));
        Append(myself.class_functions, Concat(Concat(Concat(Concat(Concat(return_type, " "), myself.current_class), "::"), function_name), myself.MakeParametersString(parameters)));
    }

    function void BeginProcessCodeBlock(int indent) {
        Append(myself.class_functions, Concat(myself.Indentation(indent), "{"));
    }

    function void FinishProcessCodeBlock(int indent) {
        Append(myself.class_functions, Concat(myself.Indentation(indent), "}"));
    }

    function void BeginProcessConditional(int indent, string r_value) {
        Append(myself.class_functions, Concat(Concat(Concat(myself.Indentation(indent), "if ("), r_value), ")"));
    }

    function void ProcessElse(int indent) {
        Append(myself.class_functions, Concat(myself.Indentation(indent), "else"));
    }

    function void FinishProcessConditional(int indent, string r_value) {
        int noop = 0;
    }

    function void BeginProcessLoop(int indent, string r_value) {
        Append(myself.class_functions, Concat(Concat(Concat(myself.Indentation(indent), "while ("), r_value), ")"));
    }

    function void FinishProcessLoop(int indent, string r_value) {
        int noop = 0;
    }

    function void ProcessRtn(int indent, string r_value) {
        Append(myself.class_functions, Concat(Concat(Concat(myself.Indentation(indent), "return "), r_value), ";"));
    }

    function void ProcessDeclaration(int indent, string type, string l_value, string r_value) {
        if (r_value == "") {
            r_value = myself.GetDefault(type);
        }

        if (r_value == "") {
            Append(myself.class_functions, Concat(Concat(Concat(Concat(myself.Indentation(indent), type), " "), l_value), ";"));
        } else {
            Append(myself.class_functions, Concat(Concat(Concat(Concat(Concat(Concat(myself.Indentation(indent), type), " "), l_value), " = "), r_value), ";"));
        }
    }

    function void ProcessAssignment(int indent, string l_value, string r_value) {
        Append(myself.class_functions, Concat(Concat(Concat(Concat(myself.Indentation(indent), l_value), " = "), r_value), ";"));
    }

    function void ProcessCall(int indent, string call) {
        Append(myself.class_functions, Concat(Concat(myself.Indentation(indent), call), ";"));
    }

    function void FinishProcessingClassFunctionDefinition(string return_type, string function_name, ParameterDeclaration[] parameters) {
        Append(myself.class_functions, "");
    }

    function void ProcessClassMemberDeclaration(string member_type, string member_name) {
        string default_value = myself.GetDefault(member_type);

        if (default_value != "") {
            Append(myself.class_init, Concat(Concat(Concat(Concat(Concat(myself.Indentation(1), "this->"), member_name), " = "), default_value), ";"));
        } else {
            Append(myself.class_init, Concat(Concat(Concat(Concat(Concat(myself.Indentation(1), "/*this->"), member_name), " = "), "NO_DEFAULT"), ";*/"));
        }

        Append(myself.class_members, Concat(Concat(Concat(Concat(myself.Indentation(1), member_type), " "), member_name), ";"));
    }

    function void FinishProcessingClass(string class_name, string implementing) {
        if (Size(myself.class_members) > 0) {
            Append(myself.class_definitions, "");
            Append(myself.class_definitions, "private:");

            int class_members_index = 0;

            while (class_members_index < Size(myself.class_members)) {
                string line = Element(myself.class_members, class_members_index);
                Append(myself.class_definitions, line);
                class_members_index = class_members_index + 1;
            }
        }

        Append(myself.class_definitions, "};");
        Append(myself.class_definitions, "");

        Append(myself.class_init, "}");
        Append(myself.class_init, "");

        int class_init_index = 0;

        while (class_init_index < Size(myself.class_init)) {
            string line = Element(myself.class_init, class_init_index);
            Append(myself.function_definitions, line);
            class_init_index = class_init_index + 1;
        }

        int class_functions_index = 0;

        while (class_functions_index < Size(myself.class_functions)) {
            string line = Element(myself.class_functions, class_functions_index);
            Append(myself.function_definitions, line);
            class_functions_index = class_functions_index + 1;
        }

        myself.current_class = "";
    }

    function void WriteCommonFunctions(S84.CTCode.System.ctcode.OutputStream destination) {
        destination.WriteLine("#ifndef CTCODE_COMMON_FUNCTIONS_VERSION_1");
        destination.WriteLine("#define CTCODE_COMMON_FUNCTIONS_VERSION_1");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("class OmniPointer");
        destination.WriteLine("{");
        destination.WriteLine("public:");
        destination.WriteLine("    OmniPointer() { value_raw = NULL; }");
        destination.WriteLine("    OmniPointer(T* value) { value_raw = value; }");
        destination.WriteLine("    template<typename U>");
        destination.WriteLine("    OmniPointer(U* value) { value_raw = value; }");
        destination.WriteLine("    OmniPointer(std::shared_ptr<T> value) { value_raw = NULL; value_shared = value; }");
        destination.WriteLine("    template<typename U>");
        destination.WriteLine("    OmniPointer(std::shared_ptr<U> value) { value_raw = NULL; value_shared = value; }");
        destination.WriteLine("    template<typename U>");
        destination.WriteLine("    OmniPointer(OmniPointer<U> value) { value_raw = value.value_raw; value_shared = value.value_shared; }");
        destination.WriteLine("");
        destination.WriteLine("    operator bool()");
        destination.WriteLine("    {");
        destination.WriteLine("        if (value_raw) return true;");
        destination.WriteLine("        return value_shared.get() != NULL;");
        destination.WriteLine("    }");
        destination.WriteLine("    T& operator*()");
        destination.WriteLine("    {");
        destination.WriteLine("        if (value_raw) return *value_raw;");
        destination.WriteLine("        return *value_shared;");
        destination.WriteLine("    }");
        destination.WriteLine("    T* operator->()");
        destination.WriteLine("    {");
        destination.WriteLine("        if (value_raw) return value_raw;");
        destination.WriteLine("        return value_shared.get();");
        destination.WriteLine("    }");
        destination.WriteLine("    T* raw()");
        destination.WriteLine("    {");
        destination.WriteLine("        if (value_raw) return value_raw;");
        destination.WriteLine("        return value_shared.get();");
        destination.WriteLine("    }");
        destination.WriteLine("");
        destination.WriteLine("    T* value_raw;");
        destination.WriteLine("    std::shared_ptr<T> value_shared;");
        destination.WriteLine("};");
        destination.WriteLine("");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline std::vector<T*> UnwrapOmniList(std::vector<OmniPointer<T>> input) {");
        destination.WriteLine("	std::vector<T*> result;");
        destination.WriteLine("	for (typename std::vector<OmniPointer<T>>::iterator index = input.begin();index != input.end();index++) {");
        destination.WriteLine("		result.push_back(index->raw());");
        destination.WriteLine("	}");
        destination.WriteLine("	return result;");
        destination.WriteLine("};");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline void ClearList(std::vector<T>& input) { input.clear(); };");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline int Size(const std::vector<T>& input) { return input.size(); };");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline T Element(const std::vector<T>& input, int element) { return input.at(element); };");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline void Append(std::vector<T>& input, T element) { input.push_back(element); };");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline void ClearMap(std::unordered_map<std::string, T>& input) { input.clear(); };");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline void SetKV(std::unordered_map<std::string, T>& input, const std::string& key, T element)");
        destination.WriteLine("{");
        destination.WriteLine("    input.erase(key);");
        destination.WriteLine("    input.insert(std::pair<std::string, T>(key, element));");
        destination.WriteLine("}");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline std::vector<std::string> Keys(const std::unordered_map<std::string, T>& input)");
        destination.WriteLine("{");
        destination.WriteLine("    std::vector<std::string> result;");
        destination.WriteLine("    for(typename std::unordered_map<std::string, T>::const_iterator index = input.begin();index != input.end();index++) {");
        destination.WriteLine("        result.push_back(index->first);");
        destination.WriteLine("    }");
        destination.WriteLine("    return result;");
        destination.WriteLine("}");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline bool HasKV(const std::unordered_map<std::string, T>& input, const std::string& key)");
        destination.WriteLine("{");
        destination.WriteLine("    typename std::unordered_map<std::string, T>::const_iterator beginning = input.find(key);");
        destination.WriteLine("    return beginning != input.end();");
        destination.WriteLine("}");
        destination.WriteLine("template<typename T>");
        destination.WriteLine("inline T GetKV(const std::unordered_map<std::string, T>& input, const std::string& key) { return input.at(key); }");
        destination.WriteLine("inline int Length(const std::string& input) { return (int)input.length(); };");
        destination.WriteLine("inline std::string At(const std::string& input, int index) { return input.substr(index, 1); };");
        destination.WriteLine("inline int IntAt(const std::string& input, int index) { return (input.at(index) + 256) % 256; };");
        destination.WriteLine("inline std::string Concat(const std::string& left, const std::string& right) { return left + right; };");
        destination.WriteLine("#endif");
    }

    function void WriteBeginingGuard(S84.CTCode.System.ctcode.OutputStream file) {
        string guard_name = myself.ToUpper(myself.StripDot(Concat(myself.base_name, "_H")));
        file.WriteLine(Concat("#ifndef ", guard_name));
        file.WriteLine(Concat("#define ", guard_name));
    }

    function string[] TokenizeBaseName(string name)
    {
        string[] base_name_tokens;
        string current_token = "";
        int index = 0;

        while (index < Length(name)) {
            string character = At(name, index);

            if (character == ".") {
                Append(base_name_tokens, current_token);
                current_token = "";
            } else {
                current_token = Concat(current_token, character);
            }

            index = index + 1;
        }

        Append(base_name_tokens, current_token);
        return base_name_tokens;
    }

    function void WriteBeginingNamespace(S84.CTCode.System.ctcode.OutputStream file) {
        string[] base_name_tokens = myself.TokenizeBaseName(myself.base_name);

        int base_name_tokens_index = 0;

        while (base_name_tokens_index < Size(base_name_tokens)) {
            string base_name_token = Element(base_name_tokens, base_name_tokens_index);
            file.WriteLine(Concat(Concat("namespace ", myself.ToLower(base_name_token)), " {"));
            base_name_tokens_index = base_name_tokens_index + 1;
        }
    }

    function void WriteEndingNamespace(S84.CTCode.System.ctcode.OutputStream file) {
        string[] base_name_tokens = myself.TokenizeBaseName(myself.base_name);

        int base_name_tokens_index = 0;

        while (base_name_tokens_index < Size(base_name_tokens)) {
            string base_name_token = Element(base_name_tokens, base_name_tokens_index);
            file.WriteLine("};");
            base_name_tokens_index = base_name_tokens_index + 1;
        }
    }

    function void WriteEndingGuard(S84.CTCode.System.ctcode.OutputStream file) {
        file.WriteLine("#endif");
    }

    function void FinishProcessingCTCodeFile() {
        string header_file_name = Concat(myself.base_name, ".hpp");
        S84.CTCode.System.ctcode.OutputStream header_file = myself.system.OpenFileWriter(header_file_name);
        string source_file_name = Concat(myself.base_name, ".cpp");
        S84.CTCode.System.ctcode.OutputStream source_file = myself.system.OpenFileWriter(source_file_name);
        myself.WriteBeginingGuard(header_file);
        header_file.writeLine("");

        if (Size(myself.includes) > 0) {
            myself.WriteLines(header_file, myself.includes);
            header_file.writeLine("");
        }

        header_file.writeLine("#include <cstring>");
        header_file.writeLine("#include <list>");
        header_file.writeLine("#include <unordered_map>");
        header_file.writeLine("#include <memory>");
        header_file.writeLine("#include <string>");
        header_file.writeLine("#include <vector>");
        header_file.writeLine("");

        myself.WriteCommonFunctions(header_file);
        header_file.writeLine("");

        myself.WriteBeginingNamespace(header_file);
        header_file.WriteLine("");

        if (Size(myself.interface_declarations) > 0) {
            myself.WriteLines(header_file, myself.interface_declarations);
            header_file.WriteLine("");
        }

        if (Size(myself.class_declarations) > 0) {
            myself.WriteLines(header_file, myself.class_declarations);
            header_file.WriteLine("");
        }

        if (Size(myself.interface_definitions) > 0) {
            myself.WriteLines(header_file, myself.interface_definitions);
        }

        myself.WriteLines(header_file, myself.class_definitions);
        myself.WriteEndingNamespace(header_file);
        header_file.writeLine("");
        myself.WriteEndingGuard(header_file);

        source_file.WriteLine(Concat(Concat("#include \"", myself.base_name), ".hpp\""));
        source_file.WriteLine("");

        myself.WriteBeginingNamespace(source_file);
        source_file.WriteLine("");

        if (Size(myself.function_definitions) > 0) {
            myself.WriteLines(source_file, myself.function_definitions);
            source_file.WriteLine("");
        }

        myself.WriteEndingNamespace(source_file);
    }

    function bool BeginsWith(string prefix, string value) {
        if (Length(prefix) > Length(value)) {
            return false;
        }

        int prefix_index = 0;

        while (prefix_index < Length(prefix)) {
            if (At(prefix, prefix_index) != At(value, prefix_index)) {
                return false;
            }
            prefix_index = prefix_index + 1;
        }

        return true;
    }

    function string GetDefault(string cpp_type) {
        if (cpp_type == "int") {
            return "0";
        }

        if (cpp_type == "std::string") {
            return "\"\"";
        }

        if (cpp_type == "bool") {
            return "false";
        }

        if (cpp_type == "float") {
            return "0.0";
        }

        if (cpp_type == "void") {
            return "NULL";
        }

        if (myself.BeginsWith("std::unordered_map<std::string, ", cpp_type)) {
            return "";
        }

        if (myself.BeginsWith("std::vector<", cpp_type)) {
            return "";
        }

        return "NULL";
    }

    function string MakeParametersString(ParameterDeclaration[] parameters) {
        string result = "(";
        int parameters_index = 0;

        while (parameters_index < Size(parameters)) {
            ParameterDeclaration parameter = Element(parameters, parameters_index);

            if (parameters_index != 0) {
                result = Concat(result, ", ");
            }

            result = Concat(Concat(Concat(result, parameter.GetType()), " "), parameter.GetName());
            parameters_index = parameters_index + 1;
        }

        result = Concat(result, ")");
        return result;
    }

    function string StripDot(string input) {
        int index;
        index = 0;
        string result;
        result = "";

        while (index < Length(input)) {
            string character;
            character = At(input, index);

            if (character == ".") {
                result = Concat(result, "_");
            } else {
                result = Concat(result, character);
            }

            index = index + 1;
        }

        return result;
    }

    function void WriteLines(S84.CTCode.System.ctcode.OutputStream destination, string[] lines) {
        int lines_index = 0;

        while (lines_index < Size(lines)) {
            string line = Element(lines, lines_index);
            destination.WriteLine(line);
            lines_index = lines_index + 1;
        }
    }

    /* These are structural functions
     * VVVVVVVV
     * VVVVVVVV
     * VVVVVVVV
     * VVVVVVVV
    */
    function int Transpile(S84.CTCode.System.ctcode.System system, S84.CTCode.dbnf.ctcode.CTCodeFile c_t_code_file, string base_name) {
        ClearList(myself.operator_precedent);
        myself.PopulateOperatorPrecedent();
        myself.system = system;
        myself.c_t_code_file = c_t_code_file;
		myself.base_name = base_name;
        myself.logger = system.GetLoggerDestination();
        myself.ProcessCTCodeFile(c_t_code_file);
        return 0;
    }

    function void ProcessCTCodeFile(S84.CTCode.dbnf.ctcode.CTCodeFile c_t_code_file)
    {
        myself.BeginProcessingCTCodeFile();
        myself.ProcessExdefs(c_t_code_file);
        myself.ProcessUnmanagedTypes(c_t_code_file);
        myself.ProcessDefinitions(c_t_code_file);
        myself.FinishProcessingCTCodeFile();
    }

    function void ProcessExdefs(S84.CTCode.dbnf.ctcode.CTCodeFile c_t_code_file)
    {
        S84.CTCode.dbnf.ctcode.ExternalDefinition[] exdefs = c_t_code_file.GetDeclarations();
        int exdefs_index = 0;

        while (exdefs_index < Size(exdefs)) {
            S84.CTCode.dbnf.ctcode.ExternalDefinition exdef = Element(exdefs, exdefs_index);
            S84.CTCode.dbnf.ctcode.QualfiedName exdef_name = exdef.GetExdef();
            myself.ProcessExdef(exdef_name.UnParse());
            exdefs_index = exdefs_index + 1;
        }
    }

    function void ProcessUnmanagedTypes(S84.CTCode.dbnf.ctcode.CTCodeFile c_t_code_file)
    {
        S84.CTCode.dbnf.ctcode.UnmanagedType[] unmanaged_types = c_t_code_file.GetUnmanagedTypes();
        int unmanaged_types_index = 0;

        while (unmanaged_types_index < Size(unmanaged_types)) {
            S84.CTCode.dbnf.ctcode.UnmanagedType unmanaged_type = Element(unmanaged_types, unmanaged_types_index);
            myself.ProcessUnmanagedType(myself.GetQualifiedTypeNameInternal(unmanaged_type.GetUnmanagedType()));
            unmanaged_types_index = unmanaged_types_index + 1;
        }
    }

    function void ProcessDefinitions(S84.CTCode.dbnf.ctcode.CTCodeFile c_t_code_file)
    {
        S84.CTCode.dbnf.ctcode.Definition[] definitions = c_t_code_file.GetDefinitions();
        int definitions_index = 0;

        while(definitions_index < Size(definitions)) {
            S84.CTCode.dbnf.ctcode.Definition definition;
            definition = Element(definitions, definitions_index);

            if (definition.GetInterfaceDef()) {
                myself.ProcessInterfaceDefinition(definition.GetInterfaceDef());
            }

            if (definition.GetClassDef()) {
                myself.ProcessClassDefinition(definition.GetClassDef());
            }

            definitions_index = definitions_index + 1;
        }
    }

    function ParameterDeclaration[] GetParameters(S84.CTCode.dbnf.ctcode.ParameterListDef parameter_list_def) {
        ParameterDeclaration[] result;

        while (parameter_list_def) {
            ParameterDeclaration parameter = new ParameterDeclaration;
            parameter.SetType(myself.GetType(parameter_list_def.GetType()));
            parameter.SetName(myself.GetVariableName(parameter_list_def.GetName()));
            Append(result, parameter);
            parameter_list_def = parameter_list_def.GetParameterTail();
        }

        return result;
    }

    function void ProcessInterfaceDefinition(S84.CTCode.dbnf.ctcode.InterfaceDef interfaceDefinition)
    {
        string interface_name = myself.GetTypeName(interfaceDefinition.GetName());
        myself.BeginProcessingInterface(interface_name);

        S84.CTCode.dbnf.ctcode.ContentDeclaration[] declarations = interfaceDefinition.GetDeclarations();

        int declarations_index = 0;

        while(declarations_index < Size(declarations)) {
            S84.CTCode.dbnf.ctcode.ContentDeclaration declaration = Element(declarations, declarations_index);
            string return_type = myself.GetType(declaration.GetType());
            string function_name = myself.GetCallName(declaration.GetName());
            ParameterDeclaration[] parameters = myself.GetParameters(declaration.GetParameters());
            myself.ProcessInterfaceFunctionDeclaration(return_type, function_name, parameters);
            declarations_index = declarations_index + 1;
        }

        myself.FinishProcessingInterface(interface_name);
    }

    function void ProcessClassDefinition(S84.CTCode.dbnf.ctcode.ClassDef classDefinition)
    {
        string class_name = myself.GetTypeName(classDefinition.GetName());
        string implementing = "";
        S84.CTCode.dbnf.ctcode.ImplementationSpec implementation_spec = classDefinition.GetImplementing();

        if (implementation_spec) {
            implementing = myself.GetQualifiedTypeNameInternal(implementation_spec.GetInterface());
        }

        myself.BeginProcessingClass(class_name, implementing);

        S84.CTCode.dbnf.ctcode.ContentDefinition[] definitions = classDefinition.GetDefinitions();
        int definitions_index = 0;

        while(definitions_index < Size(definitions)) {
            S84.CTCode.dbnf.ctcode.ContentDefinition definition = Element(definitions, definitions_index);

            if (definition.GetFunctionBody()) {
                string return_type = myself.GetType(definition.GetType());
                string function_name = myself.GetCallName(definition.GetName());
                ParameterDeclaration[] parameters = myself.GetParameters(definition.GetParameters());
                myself.BeginProcessingClassFunctionDefinition(return_type, function_name, parameters);
                myself.ProcessCodeBlockInternal(myself.GetBaseIndentation(), definition.GetFunctionBody());
                myself.FinishProcessingClassFunctionDefinition(return_type, function_name, parameters);
            } else {
                string member_type = myself.GetType(definition.GetType());
                string member_name = myself.GetVariableName(definition.GetName());
                myself.ProcessClassMemberDeclaration(member_type, member_name);
            }

            definitions_index = definitions_index + 1;
        }

        myself.FinishProcessingClass(class_name, implementing);
    }

    function void ProcessInstructionInternal(int indent, S84.CTCode.dbnf.ctcode.Instruction instruction) {
        if (instruction.GetCodeBlock()) {
            myself.ProcessCodeBlockInternal(indent, instruction.GetCodeBlock());
        }

        if (instruction.GetRtn()) {
            myself.ProcessRtnInternal(indent, instruction.GetRtn());
        }

        if (instruction.GetDeclaration()) {
            myself.ProcessDeclarationInternal(indent, instruction.GetDeclaration());
        }

        if (instruction.GetAssignment()) {
            myself.ProcessAssignmentInternal(indent, instruction.GetAssignment());
        }

        if (instruction.GetCall()) {
            myself.ProcessCallInternal(indent, instruction.GetCall());
        }

        if (instruction.GetConditional()) {
            myself.ProcessConditionalInternal(indent, instruction.GetConditional());
        }

        if (instruction.GetLoop()) {
            myself.ProcessLoopInternal(indent, instruction.GetLoop());
        }
    }

    function void ProcessCodeBlockInternal(int indent, S84.CTCode.dbnf.ctcode.CodeBlock code_block) {
        myself.BeginProcessCodeBlock(indent);

        S84.CTCode.dbnf.ctcode.Instruction[] instructions = code_block.GetInstructions();
        int instructions_index = 0;

        while (instructions_index < Size(instructions)) {
            myself.ProcessInstructionInternal(indent + 1, Element(instructions, instructions_index));
            instructions_index = instructions_index + 1;
        }

        myself.FinishProcessCodeBlock(indent);
    }

    function void ProcessConditionalInternal(int indent, S84.CTCode.dbnf.ctcode.Conditional conditional) {
        string r_value = myself.GetRValueInternal(conditional.GetRValue());
        myself.BeginProcessConditional(indent, r_value);
        myself.ProcessCodeBlockInternal(indent, conditional.GetCodeBlock());

        if (conditional.GetElseTail()) {
            S84.CTCode.dbnf.ctcode.ElseTail else_tail = conditional.GetElseTail();
            myself.ProcessElse(indent);
            myself.ProcessCodeBlockInternal(indent, else_tail.GetCodeBlock());
        }

        myself.FinishProcessConditional(indent, r_value);
    }

    function void ProcessLoopInternal(int indent, S84.CTCode.dbnf.ctcode.Loop loop) {
        string r_value = myself.GetRValueInternal(loop.GetRValue());
        myself.BeginProcessLoop(indent, r_value);
        myself.ProcessCodeBlockInternal(indent, loop.GetCodeBlock());
        myself.FinishProcessLoop(indent, r_value);
    }

    function void ProcessRtnInternal(int indent, S84.CTCode.dbnf.ctcode.Return rtn) {
        string r_value = myself.GetRValueInternal(rtn.GetRValue());
        myself.ProcessRtn(indent, r_value);
    }

    function void ProcessDeclarationInternal(int indent, S84.CTCode.dbnf.ctcode.Declaration declaration) {
        string type = myself.GetType(declaration.GetType());
        string l_value = myself.GetVariableName(declaration.GetName());
        string r_value = "";
        S84.CTCode.dbnf.ctcode.DeclarationAssign declaration_assignment = declaration.GetAssignment();

        if (declaration_assignment) {
            r_value = myself.GetRValueInternal(declaration_assignment.GetRValue());
        }

        myself.ProcessDeclaration(indent, type, l_value, r_value);
    }

    function void ProcessAssignmentInternal(int indent, S84.CTCode.dbnf.ctcode.Assignment assignment) {
        myself.ProcessAssignment(indent, myself.GetVariableChain(assignment.GetLValue()), myself.GetRValueInternal(assignment.GetRValue()));
    }

    function void ProcessCallInternal(int indent, S84.CTCode.dbnf.ctcode.Call call) {
        myself.ProcessCall(indent, myself.ConvertCallInternal(call));
    }

    function string ConvertCallInternal(S84.CTCode.dbnf.ctcode.Call call) {
        string[] name_chain;
        string[] parameters;

        if (call.GetVariable()) {
            Append(name_chain, myself.GetVariableName(call.GetVariable()));
        }

        if (call.GetFunction()) {
            Append(name_chain, myself.GetCallName(call.GetFunction()));
        }

        if (call.GetFunctionChain()) {
            S84.CTCode.dbnf.ctcode.QualfiedName function_chain = call.GetFunctionChain();
            S84.CTCode.dbnf.ctcode.NameTail name_tail = function_chain.GetTail();

            if (function_chain.GetTail()) {
                Append(name_chain, myself.GetVariableName(function_chain.GetName()));
            } else {
                Append(name_chain, myself.GetCallName(function_chain.GetName()));
            }

            while (name_tail) {
                if (name_tail.GetTail()) {
                    Append(name_chain, myself.GetVariableName(name_tail.GetName()));
                } else {
                    Append(name_chain, myself.GetCallName(name_tail.GetName()));
                }

                name_tail = name_tail.GetTail();
            }
        }

        S84.CTCode.dbnf.ctcode.ParameterList parameter_list = call.GetParameters();

        while (parameter_list) {
            Append(parameters, myself.GetRValueInternal(parameter_list.GetRValue()));
            parameter_list = parameter_list.GetParameterTail();
        }

        return myself.ConvertCall(name_chain, parameters);
    }

    function string GetSingletonType(S84.CTCode.dbnf.ctcode.SingletonType singleton_type) {
        if (singleton_type.GetPrimativeType()) {
            return myself.GetPrimativeType(singleton_type.UnParse());
        }

        if (singleton_type.GetDefinedType()) {
            S84.CTCode.dbnf.ctcode.DefinedType defined_type = singleton_type.GetDefinedType();
            return Concat(Concat("OmniPointer<", myself.GetQualifiedTypeNameInternal(defined_type.GetName())), ">");
        }

        return "";
    }

    function string GetRValueSingleBasisInternal(S84.CTCode.dbnf.ctcode.RValueSingle r_value_single) {
        S84.CTCode.dbnf.ctcode.Call call = r_value_single.GetCall();

        if (call) {
            return myself.ConvertCallInternal(call);
        }

        S84.CTCode.dbnf.ctcode.Allocate allocate = r_value_single.GetAllocate();

        if (allocate) {
            return myself.ConvertAllocate(myself.GetQualifiedTypeNameInternal(allocate.GetManagedType()));
        }

        S84.CTCode.dbnf.ctcode.Byte byte_literal = r_value_single.GetByteLiteral();

        if (byte_literal) {
            S84.CTCode.dbnf.ctcode.ByteDigit high = byte_literal.GetHigh();
            S84.CTCode.dbnf.ctcode.ByteDigit low = byte_literal.GetLow();
            return myself.ConvertByte(high.UnParse(), low.UnParse());
        }

        S84.CTCode.dbnf.ctcode.Decimal decimal_literal = r_value_single.GetDecimalLiteral();

        if (decimal_literal) {
            return myself.ConvertDecimal(decimal_literal.UnParse());
        }

        S84.CTCode.dbnf.ctcode.Number integer_literal = r_value_single.GetIntegerLiteral();

        if (integer_literal) {
            return myself.ConvertNumber(integer_literal.UnParse());
        }

        S84.CTCode.dbnf.ctcode.Boolean boolean_literal = r_value_single.GetBooleanLiteral();

        if (boolean_literal) {
            return myself.ConvertBoolean(boolean_literal.UnParse());
        }

        S84.CTCode.dbnf.ctcode.QualfiedName variable = r_value_single.GetVariable();

        if (variable) {
            return myself.ConvertVariable(myself.GetVariableChain(variable));
        }

        S84.CTCode.dbnf.ctcode.Literal string_literal = r_value_single.GetStringLiteral();

        if (string_literal) {
            return myself.ConvertString(string_literal.UnParse());
        }

        return "";
    }

    function string GetRValueSingleInternal(S84.CTCode.dbnf.ctcode.RValueSingle r_value_single) {
        S84.CTCode.dbnf.ctcode.UnaryOperator unary_operator = r_value_single.GetUnaryOperator();

        if (unary_operator) {
            return myself.UnaryOperator(unary_operator.UnParse(), myself.GetRValueSingleBasisInternal(r_value_single));
        }

        return myself.GetRValueSingleBasisInternal(r_value_single);
    }

    function void PopulateOperatorPrecedent() {
        string[] precedent_0_operators;
        Append(precedent_0_operators, "+");
        Append(precedent_0_operators, "-");
        Append(myself.operator_precedent, precedent_0_operators);

        string[] precedent_1_operators;
        Append(precedent_1_operators, "<=");
        Append(precedent_1_operators, ">=");
        Append(precedent_1_operators, "==");
        Append(precedent_1_operators, "!=");
        Append(precedent_1_operators, "<");
        Append(precedent_1_operators, ">");
        Append(myself.operator_precedent, precedent_1_operators);

        string[] precedent_2_operators;
        Append(precedent_2_operators, "&&");
        Append(myself.operator_precedent, precedent_2_operators);

        string[] precedent_3_operators;
        Append(precedent_3_operators, "||");
        Append(myself.operator_precedent, precedent_3_operators);

        string[] precedent_4_operators;
        Append(precedent_4_operators, "");
        Append(myself.operator_precedent, precedent_4_operators);
    }

    function bool OverPrecedent(string op, int precedent) {
        precedent = precedent + 1;

        while (precedent < Size(myself.operator_precedent)) {
            string[] precedent_operators = Element(myself.operator_precedent, precedent);
            int index = 0;

            while (index < Size(precedent_operators)) {
                string checking_op = Element(precedent_operators, index);

                if (checking_op == op) {
                    return true;
                }

                index = index + 1;
            }

            precedent = precedent + 1;
        }

        return false;
    }

    function string BinaryOperatorPrecedentMerge(string[] values, string[] operators, IntegerReference index, int precedent) {
        if (precedent == -1) {
            return Element(values, index.GetValue());
        }

        string r_value_l = myself.BinaryOperatorPrecedentMerge(values, operators, index, precedent - 1);

        while (index.GetValue() < Size(operators)) {
            string op = Element(operators, index.GetValue());

            if (myself.OverPrecedent(op, precedent)) {
                return r_value_l;
            }

            index.SetValue(index.GetValue() + 1);
            string r_value_r = myself.BinaryOperatorPrecedentMerge(values, operators, index, precedent - 1);
            r_value_l = myself.BinaryOperator(op, r_value_l, r_value_r);
        }

        return r_value_l;
    }

    function string GetRValueInternal(S84.CTCode.dbnf.ctcode.RValue r_value) {
        string[] values;
        string[] operators;
        IntegerReference index = new IntegerReference;
        index.SetValue(0);

        Append(values, myself.GetRValueSingleInternal(r_value.GetValue()));
        S84.CTCode.dbnf.ctcode.RValueTail r_value_tail = r_value.GetTail();

        while (r_value_tail) {
            S84.CTCode.dbnf.ctcode.BinaryOperator binary_operator = r_value_tail.GetBinaryOperator();
            Append(values, myself.GetRValueSingleInternal(r_value_tail.GetValue()));
            Append(operators, binary_operator.UnParse());
            r_value_tail = r_value_tail.GetTail();
        }

        return myself.BinaryOperatorPrecedentMerge(values, operators, index, Size(myself.operator_precedent));
    }

    function string GetQualifiedTypeNameInternal(S84.CTCode.dbnf.ctcode.QualfiedName qualified_name) {
        S84.CTCode.dbnf.ctcode.Name[] name_parts;
        Append(name_parts, qualified_name.GetName());
        S84.CTCode.dbnf.ctcode.NameTail tail = qualified_name.GetTail();

        while (tail) {
            Append(name_parts, tail.GetName());
            tail = tail.GetTail();
        }

        return myself.GetQualifiedTypeName(name_parts);
    }

    function string GetType(S84.CTCode.dbnf.ctcode.ValueType type) {
        if (type.GetDimensionalType()) {
            S84.CTCode.dbnf.ctcode.DimensionalType dimensional_type = type.GetDimensionalType();
            S84.CTCode.dbnf.ctcode.SingletonType singleton_type = dimensional_type.GetSingletonType();
            return myself.GetDimensionalType(myself.GetSingletonType(singleton_type), Size(dimensional_type.GetDimensionalNote()));
        }

        if (type.GetMapType()) {
            S84.CTCode.dbnf.ctcode.MapType map_type = type.GetMapType();
            S84.CTCode.dbnf.ctcode.SingletonType singleton_type = map_type.GetSingletonType();
            return myself.GetMapType(myself.GetSingletonType(singleton_type));
        }

        if (type.GetSingletonType()) {
            S84.CTCode.dbnf.ctcode.SingletonType singleton_type = type.GetSingletonType();
            return myself.GetSingletonType(singleton_type);
        }

        return "";
    }

    /* These are string helper functions
     * VVVVVVVV
     * VVVVVVVV
     * VVVVVVVV
     * VVVVVVVV
    */
    function string Indentation(int indent) {
        string result;
        result = "";

        while (indent > 0) {
            indent = indent - 1;
            result = Concat(result, "    ");
        }

        return result;
    }

    function string SnakeCaseToCamelCase(string snake_case)
    {
        bool capitalize_this_letter = true;
        string camel_case = "";
        int index;
        index = 0;

        while (index < Length(snake_case)) {
            string source_character = At(snake_case, index);

            if (source_character == "_") {
                capitalize_this_letter = true;
            } else {
                if (capitalize_this_letter == true)
                {
                    string upper_character = myself.CharacterToUpper(source_character);
                    capitalize_this_letter = false;
                    camel_case = Concat(camel_case, upper_character);
                } else {
                    capitalize_this_letter = false;
                    camel_case = Concat(camel_case, source_character);
                }
            }

            index = index + 1;
        }

        return camel_case;
    }

    function string CamelCaseToSnakeCase(string camel_case) {
        string delimiter = "_";
        string snake_case = "";
        int index = 0;

        while (index < Length(camel_case)) {
            string source_character = At(camel_case, index);
            string lower_character = myself.CharacterToLower(source_character);

            if (myself.IsUpper(source_character) || myself.IsDigit(source_character)) {
                bool is_first_character = Length(snake_case) == 0;

                if (!is_first_character) {
                    snake_case = Concat(snake_case, delimiter);
                }
            }

            snake_case = Concat(snake_case, lower_character);
            index = index + 1;
        }

        return snake_case;
    }

    function bool IsUpper(string character) {
        bool result;
        result = false;
        result = result || character == "A";
        result = result || character == "B";
        result = result || character == "C";
        result = result || character == "D";
        result = result || character == "E";
        result = result || character == "F";
        result = result || character == "G";
        result = result || character == "H";
        result = result || character == "I";
        result = result || character == "J";
        result = result || character == "K";
        result = result || character == "L";
        result = result || character == "M";
        result = result || character == "N";
        result = result || character == "O";
        result = result || character == "P";
        result = result || character == "Q";
        result = result || character == "R";
        result = result || character == "S";
        result = result || character == "T";
        result = result || character == "U";
        result = result || character == "V";
        result = result || character == "W";
        result = result || character == "X";
        result = result || character == "Y";
        result = result || character == "Z";
        return result;
    }

    function bool IsDigit(string character) {
        bool result;
        result = false;
        result = result || character == "0";
        result = result || character == "1";
        result = result || character == "2";
        result = result || character == "3";
        result = result || character == "4";
        result = result || character == "5";
        result = result || character == "6";
        result = result || character == "7";
        result = result || character == "8";
        result = result || character == "9";
        return result;
    }

    function string ToLower(string input) {
        int index = 0;
        string result = "";

        while (index < Length(input)) {
            string character = At(input, index);
            string lowerCharacter = myself.CharacterToLower(character);
            result = Concat(result, lowerCharacter);
            index = index + 1;
        }

        return result;
    }

    function string CharacterToLower(string input) {
        if (input == "A") {
            return "a";
        }

        if (input == "B") {
            return "b";
        }

        if (input == "C") {
            return "c";
        }

        if (input == "D") {
            return "d";
        }

        if (input == "E") {
            return "e";
        }

        if (input == "F") {
            return "f";
        }

        if (input == "G") {
            return "g";
        }

        if (input == "H") {
            return "h";
        }

        if (input == "I") {
            return "i";
        }

        if (input == "J") {
            return "j";
        }

        if (input == "K") {
            return "k";
        }

        if (input == "L") {
            return "l";
        }

        if (input == "M") {
            return "m";
        }

        if (input == "N") {
            return "n";
        }

        if (input == "O") {
            return "o";
        }

        if (input == "P") {
            return "p";
        }

        if (input == "Q") {
            return "q";
        }

        if (input == "R") {
            return "r";
        }

        if (input == "S") {
            return "s";
        }

        if (input == "T") {
            return "t";
        }

        if (input == "U") {
            return "u";
        }

        if (input == "V") {
            return "v";
        }

        if (input == "W") {
            return "w";
        }

        if (input == "X") {
            return "x";
        }

        if (input == "Y") {
            return "y";
        }

        if (input == "Z") {
            return "z";
        }

        return input;
    }

    function string ToUpper(string input) {
        int index = 0;
        string result = "";

        while (index < Length(input)) {
            string character = At(input, index);
            string upperCharacter = myself.CharacterToUpper(character);
            result = Concat(result, upperCharacter);
            index = index + 1;
        }

        return result;
    }

    function string CharacterToUpper(string input) {
        if (input == "a") {
            return "A";
        }

        if (input == "b") {
            return "B";
        }

        if (input == "c") {
            return "C";
        }

        if (input == "d") {
            return "D";
        }

        if (input == "e") {
            return "E";
        }

        if (input == "f") {
            return "F";
        }

        if (input == "g") {
            return "G";
        }

        if (input == "h") {
            return "H";
        }

        if (input == "i") {
            return "I";
        }

        if (input == "j") {
            return "J";
        }

        if (input == "k") {
            return "K";
        }

        if (input == "l") {
            return "L";
        }

        if (input == "m") {
            return "M";
        }

        if (input == "n") {
            return "N";
        }

        if (input == "o") {
            return "O";
        }

        if (input == "p") {
            return "P";
        }

        if (input == "q") {
            return "Q";
        }

        if (input == "r") {
            return "R";
        }

        if (input == "s") {
            return "S";
        }

        if (input == "t") {
            return "T";
        }

        if (input == "u") {
            return "U";
        }

        if (input == "v") {
            return "V";
        }

        if (input == "w") {
            return "W";
        }

        if (input == "x") {
            return "X";
        }

        if (input == "y") {
            return "Y";
        }

        if (input == "z") {
            return "Z";
        }

        return input;
    }
}