exdef S84.CTCode.dbnf.ctcode;
exdef S84.CTCode.System.ctcode;
exdef S84.CTCode.Transpiler.ctcode;

class CPPTranspiler implements S84.CTCode.Transpiler.ctcode.Transpiler {
    string[] saved_unmanaged_types;

    function int Transpile(S84.CTCode.System.ctcode.System system, S84.CTCode.dbnf.ctcode.CTCodeFile ct_code_file, string base_name) {
        S84.CTCode.System.ctcode.OutputStream logger = system.GetLoggerDestination();
        S84.CTCode.System.ctcode.OutputStream header = system.OpenFileWriter(Concat(base_name, ".hpp"));
        S84.CTCode.System.ctcode.OutputStream implementation = system.OpenFileWriter(Concat(base_name, ".cpp"));
		string[] base_name_tokens = myself.TokenizeBaseName(base_name);
	    myself.SetSavedUnmanagedTypes(myself.GetUnmanagedTypes(ct_code_file.GetUnmanagedTypes()));
		myself.GenerateHeader(ct_code_file, header, base_name_tokens);
		myself.GenerateImplementation(ct_code_file, implementation, base_name, base_name_tokens);
        return 0;
    }

    function void SetSavedUnmanagedTypes(string[] value)
    {
        myself.saved_unmanaged_types = value;
    }

    function bool IsUnmanagedType(string type_name)
    {
        int index = 0;

        while (index < Size(myself.saved_unmanaged_types))
        {
            if (type_name == Element(myself.saved_unmanaged_types, index))
            {
                return true;
            }

            index = index + 1;
        }

        return false;
    }

    function void GenerateHeader(S84.CTCode.dbnf.ctcode.CTCodeFile ctcodeFile, S84.CTCode.System.ctcode.OutputStream header, string[] base_name_tokens)
    {
        string guard_name = myself.GenerateGuardName(base_name_tokens);
        header.WriteLine(Concat("#ifndef ", guard_name));
        header.WriteLine(Concat("#define ", guard_name));
        header.WriteLine("");

        S84.CTCode.dbnf.ctcode.ExternalDefinition[] exdefs = ctcodeFile.GetDeclarations();

        int index = 0;

        while (index < Size(exdefs)) {
            S84.CTCode.dbnf.ctcode.ExternalDefinition exdef;
            exdef = Element(exdefs, index);
            S84.CTCode.dbnf.ctcode.QualfiedName exdef_name;
            exdef_name = exdef.GetExdef();
            header.WriteLine(Concat("#include \"", Concat(myself.GetExdefHeaderString(exdef_name), "\"")));
            index = index + 1;
        }

        header.WriteLine("");
        header.WriteLine("#include <cstring>");
        header.WriteLine("#include <list>");
        header.WriteLine("#include <unordered_map>");
        header.WriteLine("#include <memory>");
        header.WriteLine("#include <string>");
        header.WriteLine("#include <vector>");

        myself.WriteCTCodeCommonFunctions(header);

        header.WriteLine("");

        index = 0;

        while (index < Size(base_name_tokens)) {
            string base_name_token;
            base_name_token = Element(base_name_tokens, index);
            header.WriteLine(Concat("namespace ", myself.ToLower(base_name_token)));
            header.WriteLine("{");
            index = index + 1;
        }

        header.WriteLine("namespace ctcode");
        header.WriteLine("{");
        myself.WriteForwardDeclaration(ctcodeFile, header);
        myself.WriteClassDeclarations(ctcodeFile, header);

        index = 0;

        while (index < Size(base_name_tokens)) {
            header.WriteLine("};");
            index = index + 1;
        }
        
        header.WriteLine("};");
        header.WriteLine("");
        header.WriteLine("#endif");
    }

    function void WriteCTCodeCommonFunctions(S84.CTCode.System.ctcode.OutputStream header)
    {
        header.WriteLine("");
        header.WriteLine("#ifndef CTCODE_COMMON_FUNCTIONS_VERSION_1");
        header.WriteLine("#define CTCODE_COMMON_FUNCTIONS_VERSION_1");
        header.WriteLine("template<typename T>");
        header.WriteLine("class OmniPointer");
        header.WriteLine("{");
        header.WriteLine("public:");
        header.WriteLine("    OmniPointer() { value_raw = NULL; }");
        header.WriteLine("    OmniPointer(T* value) { value_raw = value; }");
        header.WriteLine("    template<typename U>");
        header.WriteLine("    OmniPointer(U* value) { value_raw = value; }");
        header.WriteLine("    OmniPointer(std::shared_ptr<T> value) { value_raw = NULL; value_shared = value; }");
        header.WriteLine("    template<typename U>");
        header.WriteLine("    OmniPointer(std::shared_ptr<U> value) { value_raw = NULL; value_shared = value; }");
        header.WriteLine("");
        header.WriteLine("    operator bool()");
        header.WriteLine("    {");
        header.WriteLine("        if (value_raw) return true;");
        header.WriteLine("        return value_shared.get() != NULL;");
        header.WriteLine("    }");
        header.WriteLine("    T& operator*()");
        header.WriteLine("    {");
        header.WriteLine("        if (value_raw) return *value_raw;");
        header.WriteLine("        return *value_shared;");
        header.WriteLine("    }");
        header.WriteLine("    T* operator->()");
        header.WriteLine("    {");
        header.WriteLine("        if (value_raw) return value_raw;");
        header.WriteLine("        return value_shared.get();");
        header.WriteLine("    }");
        header.WriteLine("    T* raw()");
        header.WriteLine("    {");
        header.WriteLine("        if (value_raw) return value_raw;");
        header.WriteLine("        return value_shared.get();");
        header.WriteLine("    }");
        header.WriteLine("");
        header.WriteLine("private:");
        header.WriteLine("    T* value_raw;");
        header.WriteLine("    std::shared_ptr<T> value_shared;");
        header.WriteLine("};");
        header.WriteLine("");
        header.WriteLine("template<typename T>");
        header.WriteLine("inline std::vector<T*> UnwrapOmniList(std::vector<OmniPointer<T>> input) {");
        header.WriteLine("	std::vector<T*> result;");
        header.WriteLine("	for (typename std::vector<OmniPointer<T>>::iterator index = input.begin();index != input.end();index++) {");
        header.WriteLine("		result.push_back(index->raw());");
        header.WriteLine("	}");
        header.WriteLine("	return result;");
        header.WriteLine("};");
        header.WriteLine("template<typename T>");
        header.WriteLine("inline void ClearList(std::vector<T>& input) { input.clear(); };");
        header.WriteLine("template<typename T>");
        header.WriteLine("inline int Size(const std::vector<T>& input) { return input.size(); };");
        header.WriteLine("template<typename T>");
        header.WriteLine("inline T Element(const std::vector<T>& input, int element) { return input.at(element); };");
        header.WriteLine("template<typename T>");
        header.WriteLine("inline void Append(std::vector<T>& input, T element) { input.push_back(element); };");
        header.WriteLine("template<typename T>");
        header.WriteLine("inline void ClearMap(std::unordered_map<std::string, T>& input) { input.clear(); };");
        header.WriteLine("template<typename T>");
        header.WriteLine("inline void SetKV(std::unordered_map<std::string, T>& input, const std::string& key, T element)");
        header.WriteLine("{");
        header.WriteLine("    input.erase(key);");
        header.WriteLine("    input.insert(std::pair<std::string, T>(key, element));");
        header.WriteLine("}");
        header.WriteLine("template<typename T>");
        header.WriteLine("inline std::vector<std::string> Keys(const std::unordered_map<std::string, T>& input)");
        header.WriteLine("{");
        header.WriteLine("    std::vector<std::string> result;");
        header.WriteLine("    for(typename std::unordered_map<std::string, T>::const_iterator index = input.begin();index != input.end();index++) {");
        header.WriteLine("        result.push_back(index->first);");
        header.WriteLine("    }");
        header.WriteLine("    return result;");
        header.WriteLine("}");
        header.WriteLine("template<typename T>");
        header.WriteLine("inline bool HasKV(const std::unordered_map<std::string, T>& input, const std::string& key)");
        header.WriteLine("{");
        header.WriteLine("    typename std::unordered_map<std::string, T>::const_iterator beginning = input.find(key);");
        header.WriteLine("    return beginning != input.end();");
        header.WriteLine("}");
        header.WriteLine("template<typename T>");
        header.WriteLine("inline T GetKV(const std::unordered_map<std::string, T>& input, const std::string& key) { return input.at(key); }");
        header.WriteLine("inline int Length(const std::string& input) { return (int)input.length(); };");
        header.WriteLine("inline std::string At(const std::string& input, int index) { return input.substr(index, 1); };");
        header.WriteLine("inline int IntAt(const std::string& input, int index) { return (input.at(index) + 256) % 256; };");
        header.WriteLine("inline std::string Concat(const std::string& left, const std::string& right) { return left + right; };");
        header.WriteLine("#endif");
    }

    function void WriteForwardDeclaration(S84.CTCode.dbnf.ctcode.CTCodeFile ctcodeFile, S84.CTCode.System.ctcode.OutputStream header)
    {
        S84.CTCode.dbnf.ctcode.Definition[] definitions = ctcodeFile.GetDefinitions();

        int index = 0;

        while(index < Size(definitions)) {
            S84.CTCode.dbnf.ctcode.Definition definition;
            definition = Element(definitions, index);
            S84.CTCode.dbnf.ctcode.InterfaceDef interfaceDefinition = definition.GetInterfaceDef();
            S84.CTCode.dbnf.ctcode.ClassDef classDefinition = definition.GetClassDef();

            if (interfaceDefinition) {
                header.WriteLine(Concat("class ", Concat(myself.GenerateClassName(interfaceDefinition.GetName()), ";")));
            }

            if (classDefinition) {
                header.WriteLine(Concat("class ", Concat(myself.GenerateClassName(classDefinition.GetName()), ";")));
            }

            index = index + 1;
        }
    }

    function void WriteClassDeclarations(S84.CTCode.dbnf.ctcode.CTCodeFile ctcodeFile, S84.CTCode.System.ctcode.OutputStream header)
    {
        S84.CTCode.dbnf.ctcode.Definition[] definitions = ctcodeFile.GetDefinitions();

        header.WriteLine("");
        int index;
        index = 0;

        while(index < Size(definitions)) {
            S84.CTCode.dbnf.ctcode.Definition definition;
            definition = Element(definitions, index);

            if (definition.GetInterfaceDef()) {
                myself.WriteInterfaceDeclaration(definition.GetInterfaceDef(), header);
            }

            if (definition.GetClassDef()) {
                myself.WriteClassDeclaration(definition.GetClassDef(), header);
            }

            index = index + 1;
        }
    }

    function void WriteInterfaceDeclaration(S84.CTCode.dbnf.ctcode.InterfaceDef interfaceDefinition, S84.CTCode.System.ctcode.OutputStream header)
    {
        string class_name = "";
        class_name = myself.GenerateClassName(interfaceDefinition.GetName());
        header.WriteLine("");
        header.WriteLine(Concat("class ", class_name));
        header.WriteLine("{");
        header.WriteLine("public:");
        header.WriteLine(Concat("    inline ", Concat(class_name, "() {};")));
        header.WriteLine(Concat("    inline ~", Concat(class_name, "() {};")));

        S84.CTCode.dbnf.ctcode.ContentDeclaration[] declarations = interfaceDefinition.GetDeclarations();

        int index;
        index = 0;

        if (Size(declarations) > 0) {
            header.WriteLine("");

            while(index < Size(declarations)) {
                S84.CTCode.dbnf.ctcode.ContentDeclaration declaration;
                declaration = Element(declarations, index);

                header.WriteLine(Concat("    virtual ", Concat(myself.GetType(declaration.GetType()), Concat(" ", Concat(myself.GenerateCallName(declaration.GetName()), Concat("(", Concat(myself.GenerateParameterList(declaration.GetParameters()), ") = 0;")))))));

                index = index + 1;
            }
        }

        header.WriteLine("};");
    }

    function void WriteClassDeclaration(S84.CTCode.dbnf.ctcode.ClassDef classDefinition, S84.CTCode.System.ctcode.OutputStream header)
    {
        string class_name;
        class_name = myself.GenerateClassName(classDefinition.GetName());
        header.WriteLine("");
        header.WriteLine(Concat("class ", class_name));
        myself.WriteImplementationSpec(classDefinition.GetImplementing(), header);
        header.WriteLine("{");
        header.WriteLine("public:");
        header.WriteLine(Concat("    inline ", Concat(class_name, "() {};")));
        header.WriteLine(Concat("    inline ~", Concat(class_name, "() {};")));

        S84.CTCode.dbnf.ctcode.ContentDefinition[] definitions = classDefinition.GetDefinitions();
        S84.CTCode.dbnf.ctcode.ContentDefinition[] functionDefinitions;
        S84.CTCode.dbnf.ctcode.ContentDefinition[] memberDefinitions;

        int index;
        index = 0;

        while(index < Size(definitions)) {
            S84.CTCode.dbnf.ctcode.ContentDefinition definition;
            definition = Element(definitions, index);

            if (definition.GetFunctionBody()) {
                Append(functionDefinitions, definition);
            } else {
                Append(memberDefinitions, definition);
            }

            index = index + 1;
        }

        if(Size(functionDefinitions) > 0)
        {
            header.WriteLine("");

            index = 0;

            while (index < Size(functionDefinitions)) {
                S84.CTCode.dbnf.ctcode.ContentDefinition definition;
                definition = Element(functionDefinitions, index);
                header.WriteLine(Concat("    ", Concat(myself.GetType(definition.GetType()), Concat(" ", Concat(myself.GenerateCallName(definition.GetName()), Concat("(", Concat(myself.GenerateParameterList(definition.GetParameters()), ");")))))));
                index = index + 1;
            }
        }

        if(Size(memberDefinitions) > 0)
        {
            header.WriteLine("");
            header.WriteLine("private:");

            index = 0;

            while (index < Size(memberDefinitions)) {
                S84.CTCode.dbnf.ctcode.ContentDefinition definition;
                definition = Element(memberDefinitions, index);
                header.WriteLine(Concat("    ", Concat(myself.GetType(definition.GetType()), Concat(" ", Concat(myself.GenerateVariableName(definition.GetName()), ";")))));
                index = index + 1;
            }
        }

        header.WriteLine("};");
    }

    function void WriteImplementationSpec(S84.CTCode.dbnf.ctcode.ImplementationSpec implementationSpec, S84.CTCode.System.ctcode.OutputStream header)
    {
        if (implementationSpec) {
            S84.CTCode.dbnf.ctcode.QualfiedName qualified_name = implementationSpec.GetInterface();
            header.WriteLine(Concat(": public ", myself.GetRawDefinedType(qualified_name)));
        }
    }

    function void GenerateImplementation(S84.CTCode.dbnf.ctcode.CTCodeFile ctcodeFile, S84.CTCode.System.ctcode.OutputStream implementation, string base_name, string[] base_name_tokens)
    {
        implementation.WriteLine(Concat("#include \"", Concat(base_name, ".hpp\"")));
        implementation.WriteLine("");

        S84.CTCode.dbnf.ctcode.ExternalDefinition[] exdefs = ctcodeFile.GetDeclarations();

        int index;
        index = 0;

        while (index < Size(exdefs)) {
            S84.CTCode.dbnf.ctcode.ExternalDefinition exdef;
            exdef = Element(exdefs, index);
            S84.CTCode.dbnf.ctcode.QualfiedName exdef_name;
            exdef_name = exdef.GetExdef();
            implementation.WriteLine(Concat("#include \"", Concat(myself.GetExdefHeaderString(exdef_name), "\"")));
            index = index + 1;
        }

        implementation.WriteLine("");

        index = 0;

        while (index < Size(base_name_tokens)) {
            string base_name_token;
            base_name_token = Element(base_name_tokens, index);
            implementation.WriteLine(Concat("namespace ", myself.ToLower(base_name_token)));
            implementation.WriteLine("{");
            index = index + 1;
        }

        implementation.WriteLine("namespace ctcode");
        implementation.WriteLine("{");

        myself.WriteFunctionDefinitions(ctcodeFile, implementation);

        index = 0;

        while (index < Size(base_name_tokens)) {
            implementation.WriteLine("};");
            index = index + 1;
        }
        
        implementation.WriteLine("};");
    }

    function void WriteFunctionDefinitions(S84.CTCode.dbnf.ctcode.CTCodeFile ctcodeFile, S84.CTCode.System.ctcode.OutputStream implementation)
    {
        S84.CTCode.dbnf.ctcode.Definition[] definitions = ctcodeFile.GetDefinitions();
        S84.CTCode.dbnf.ctcode.ClassDef[] classDefinitions;

        int index;
        index = 0;

        while (index < Size(definitions)) {
            S84.CTCode.dbnf.ctcode.Definition definition;
            definition = Element(definitions, index);
            S84.CTCode.dbnf.ctcode.ClassDef classDefinition;
            classDefinition = definition.GetClassDef();

            if (classDefinition) {
                Append(classDefinitions, classDefinition);
            }

            index = index + 1;
        }

        index = 0;

        while (index < Size(classDefinitions)) {
            S84.CTCode.dbnf.ctcode.ClassDef classDefinition;
            classDefinition = Element(classDefinitions, index);
            myself.WriteClassDefinition(classDefinition, implementation);
            index = index + 1;
        }
    }

    function void WriteClassDefinition(S84.CTCode.dbnf.ctcode.ClassDef classDefinition, S84.CTCode.System.ctcode.OutputStream implementation)
    {
        string class_name;
        class_name = myself.GenerateClassName(classDefinition.GetName());

        S84.CTCode.dbnf.ctcode.ContentDefinition[] definitions = classDefinition.GetDefinitions();

        S84.CTCode.dbnf.ctcode.ContentDefinition[] functionDefinitions;

        int index;
        index = 0;

        while (index < Size(definitions)) {
            S84.CTCode.dbnf.ctcode.ContentDefinition definition;
            definition = Element(definitions, index);

            if (definition.GetFunctionBody()) {
                Append(functionDefinitions, definition);
            }

            index = index + 1;
        }

        if(Size(functionDefinitions) > 0)
        {
            index = 0;

            while (index < Size(functionDefinitions)) {
                S84.CTCode.dbnf.ctcode.ContentDefinition definition;
                definition = Element(functionDefinitions, index);
                implementation.WriteLine(Concat("    ", Concat(myself.GetType(definition.GetType()), Concat(" ", Concat(class_name, Concat("::", Concat(myself.GenerateCallName(definition.GetName()), Concat("(", Concat(myself.GenerateParameterList(definition.GetParameters()), ")")))))))));
                myself.WriteCodeBlock(1, implementation, definition.GetFunctionBody(), true);
                index = index + 1;
            }
        }
    }

    function void WriteInstruction(int indent, S84.CTCode.System.ctcode.OutputStream implementation, S84.CTCode.dbnf.ctcode.Instruction instruction, bool add_newline_after_code_block) {
        if (instruction.GetCodeBlock()) {
            myself.WriteCodeBlock(indent, implementation, instruction.GetCodeBlock(), add_newline_after_code_block);
        }

        if (instruction.GetRtn()) {
            myself.WriteRtn(indent, implementation, instruction.GetRtn());
        }

        if (instruction.GetDeclaration()) {
            myself.WriteDeclaration(indent, implementation, instruction.GetDeclaration());
        }

        if (instruction.GetAssignment()) {
            myself.WriteAssignment(indent, implementation, instruction.GetAssignment());
        }

        if (instruction.GetCall()) {
            myself.WriteCall(indent, implementation, instruction.GetCall());
        }

        if (instruction.GetConditional()) {
            myself.WriteConditional(indent, implementation, instruction.GetConditional(), add_newline_after_code_block);
        }

        if (instruction.GetLoop()) {
            myself.WriteLoop(indent, implementation, instruction.GetLoop(), add_newline_after_code_block);
        }
    }

    function void WriteCodeBlock(int indent, S84.CTCode.System.ctcode.OutputStream implementation, S84.CTCode.dbnf.ctcode.CodeBlock code_block, bool add_newline_after_code_block) {
        implementation.WriteLine(Concat(myself.Indentation(indent), "{"));

        S84.CTCode.dbnf.ctcode.Instruction[] instructions = code_block.GetInstructions();
        int index;
        index = 0;
        int last;
        last = Size(instructions) - 1;

        while (index < Size(instructions)) {
            myself.WriteInstruction(indent + 1, implementation, Element(instructions, index), index != last);
            index = index + 1;
        }

        implementation.WriteLine(Concat(myself.Indentation(indent), "}"));

        if (add_newline_after_code_block) {
            implementation.WriteLine("");
        }
    }

    function void WriteConditional(int indent, S84.CTCode.System.ctcode.OutputStream implementation, S84.CTCode.dbnf.ctcode.Conditional conditional, bool add_newline_after_code_block) {
        implementation.WriteLine(Concat(myself.Indentation(indent), Concat("if (", Concat(myself.GetRValueString(conditional.GetRValue()), ")"))));

        if (conditional.GetElseTail()) {
            S84.CTCode.dbnf.ctcode.ElseTail else_tail;
            else_tail = conditional.GetElseTail();
            myself.WriteCodeBlock(indent, implementation, conditional.GetCodeBlock(), false);
            implementation.WriteLine(Concat(myself.Indentation(indent), "else"));
            myself.WriteCodeBlock(indent, implementation, else_tail.GetCodeBlock(), add_newline_after_code_block);
        } else {
            myself.WriteCodeBlock(indent, implementation, conditional.GetCodeBlock(), add_newline_after_code_block);
        }
    }

    function void WriteLoop(int indent, S84.CTCode.System.ctcode.OutputStream implementation, S84.CTCode.dbnf.ctcode.Loop loop, bool add_newline_after_code_block) {
        implementation.WriteLine(Concat(myself.Indentation(indent), Concat("while (", Concat(myself.GetRValueString(loop.GetRValue()), ")"))));
        myself.WriteCodeBlock(indent, implementation, loop.GetCodeBlock(), add_newline_after_code_block);
    }

    function void WriteRtn(int indent, S84.CTCode.System.ctcode.OutputStream implementation, S84.CTCode.dbnf.ctcode.Return rtn) {
        implementation.WriteLine(Concat(myself.Indentation(indent), Concat("return ", Concat(myself.GetRValueString(rtn.GetRValue()), ";"))));
    }

    function void WriteDeclaration(int indent, S84.CTCode.System.ctcode.OutputStream implementation, S84.CTCode.dbnf.ctcode.Declaration declaration) {
        string assignment_suffix;
        assignment_suffix = "";

        if (declaration.GetAssignment()) {
            S84.CTCode.dbnf.ctcode.DeclarationAssign assignment;
            assignment = declaration.GetAssignment();
            assignment_suffix = Concat(" = ", myself.GetRValueString(assignment.GetRValue()));
        }

        implementation.WriteLine(Concat(myself.Indentation(indent), Concat(myself.GetVariableDefinition(declaration.GetType(), declaration.GetName()), Concat(assignment_suffix, ";"))));
    }

    function void WriteAssignment(int indent, S84.CTCode.System.ctcode.OutputStream implementation, S84.CTCode.dbnf.ctcode.Assignment assignment) {
        implementation.WriteLine(Concat(myself.Indentation(indent), Concat(myself.GenerateVariableChain(assignment.GetLValue()), Concat(" = ", Concat(myself.GetRValueString(assignment.GetRValue()), ";")))));
    }

    function void WriteCall(int indent, S84.CTCode.System.ctcode.OutputStream implementation, S84.CTCode.dbnf.ctcode.Call call) {
        implementation.WriteLine(Concat(myself.Indentation(indent), Concat(myself.GetCallString(call), ";")));
    }

    function string GetExdefHeaderString(S84.CTCode.dbnf.ctcode.QualfiedName exdef_name) {
        return Concat(exdef_name.UnParse(), ".hpp");
    }

    function string[] GetUnmanagedTypes(S84.CTCode.dbnf.ctcode.UnmanagedType[] unmanaged_types)
    {
        string[] unmanaged_type_strings;
        int index;
        index = 0;

        while (index < Size(unmanaged_types)) {
            S84.CTCode.dbnf.ctcode.UnmanagedType unmanaged_type = Element(unmanaged_types, index);
            Append(unmanaged_type_strings, myself.GetRawDefinedType(unmanaged_type.GetUnmanagedType()));
            index = index + 1;
        }

        return unmanaged_type_strings;
    }

    function string Indentation(int indent) {
        string result;
        result = "";

        while (indent > 0) {
            indent = indent - 1;
            result = Concat(result, "    ");
        }

        return result;
    }

    function string GetRValueSingleString(S84.CTCode.dbnf.ctcode.RValueSingle rValueSingle) {
        return Concat(myself.GetRValueSingleUnaryString(rValueSingle), myself.GetRValueSingleCoreString(rValueSingle));
    }

    function string GetRValueSingleUnaryString(S84.CTCode.dbnf.ctcode.RValueSingle rValueSingle) {
        if (rValueSingle.GetUnaryOperator()) {
            S84.CTCode.dbnf.ctcode.UnaryOperator unaryOperator;
            unaryOperator = rValueSingle.GetUnaryOperator();

            if (unaryOperator.GetNegation()) {
                return "!";
            }

            return "/*WARNING UnaryOperator FALL THROUGH*/";
        } else {
            return "";
        }
    }

    function string GetCallString(S84.CTCode.dbnf.ctcode.Call call) {
        string result;
        result = "";

        if (call.GetVariable()) {
            result = Concat(result, Concat(myself.GenerateVariableName(call.GetVariable()), "->"));
        }

        if (call.GetFunction()) {
            result = Concat(result, myself.GenerateCallName(call.GetFunction()));
        }

        if (call.GetFunctionChain()) {
            S84.CTCode.dbnf.ctcode.QualfiedName function_chain = call.GetFunctionChain();
            S84.CTCode.dbnf.ctcode.NameTail name_tail = function_chain.GetTail();

            if (function_chain.GetTail()) {
                result = Concat(Concat(result, myself.GenerateVariableName(function_chain.GetName())), "->");
            } else {
                result = Concat(result, myself.GenerateCallName(function_chain.GetName()));
            }

            while (name_tail) {
                if (name_tail.GetTail()) {
                    result = Concat(Concat(result, myself.GenerateVariableName(name_tail.GetName())), "->");
                } else {
                    result = Concat(result, myself.GenerateCallName(name_tail.GetName()));
                }

                name_tail = name_tail.GetTail();
            }
        }

        result = Concat(Concat(Concat(result, "("), myself.GenerateCallingParameterList(call.GetParameters())), ")");
        return result;
    }

    function string GetRValueSingleCoreString(S84.CTCode.dbnf.ctcode.RValueSingle rValueSingle) {
        if (rValueSingle.GetCall()) {
            return myself.GetCallString(rValueSingle.GetCall());
        }

        if (rValueSingle.GetAllocate()) {
            S84.CTCode.dbnf.ctcode.Allocate allocate = rValueSingle.GetAllocate();
            string raw_type = myself.GetRawDefinedType(allocate.GetManagedType());
            return Concat("std::shared_ptr<", Concat(raw_type, Concat(">(new ", Concat(raw_type, "())"))));
        }

        if (rValueSingle.GetByteLiteral()) {
            return rValueSingle.UnParse();
        }

        if (rValueSingle.GetDecimalLiteral()) {
            return rValueSingle.UnParse();
        }

        if (rValueSingle.GetIntegerLiteral()) {
            return rValueSingle.UnParse();
        }

        if (rValueSingle.GetBooleanLiteral()) {
            return rValueSingle.UnParse();
        }

        if (rValueSingle.GetVariable()) {
            return myself.GenerateVariableChain(rValueSingle.GetVariable());
        }

        if (rValueSingle.GetStringLiteral()) {
            return Concat(Concat("std::string(", rValueSingle.UnParse()), ")");
        }

        return "/*WARNING RValueSingle FALL THROUGH*/";
    }

    function string GetOperator(S84.CTCode.dbnf.ctcode.BinaryOperator op) {
        if (op.GetAddition()) {
            return "+";
        }

        if (op.GetSubtraction()) {
            return "-";
        }

        if (op.GetLessThan()) {
            return "<";
        }

        if (op.GetLessThanEq()) {
            return "<=";
        }

        if (op.GetEquality()) {
            return "==";
        }

        if (op.GetNotEquality()) {
            return "!=";
        }

        if (op.GetGreaterThanEq()) {
            return ">=";
        }

        if (op.GetGreaterThan()) {
            return ">";
        }

        if (op.GetOrOp()) {
            return "||";
        }

        if (op.GetAndOp()) {
            return "&&";
        }

        return "/*WARNING BinaryOperator FALL THROUGH*/";
    }

    function string GetRValueTail(S84.CTCode.dbnf.ctcode.RValueTail rValueTail) {
        if (rValueTail) {
            S84.CTCode.dbnf.ctcode.BinaryOperator op;
            op = rValueTail.GetBinaryOperator();

            return Concat(" ", Concat(myself.GetOperator(op), Concat(" ", Concat(myself.GetRValueSingleString(rValueTail.GetValue()), myself.GetRValueTail(rValueTail.GetTail())))));
        }

        return "";
    }

    function string GetRValueString(S84.CTCode.dbnf.ctcode.RValue rValue) {
        return Concat(myself.GetRValueSingleString(rValue.GetValue()), myself.GetRValueTail(rValue.GetTail()));
    }

    function string GetVariableDefinition(S84.CTCode.dbnf.ctcode.ValueType type, S84.CTCode.dbnf.ctcode.Name name) {
        return Concat(myself.GetType(type), Concat(" ", myself.GenerateVariableName(name)));
    }

    function string GetParameterString(S84.CTCode.dbnf.ctcode.ParameterListDef parameter) {
        return myself.GetVariableDefinition(parameter.GetType(), parameter.GetName());
    }

    function string GenerateParameterListTail(S84.CTCode.dbnf.ctcode.ParameterListDef parameters) {
        if (parameters) {
            return Concat(", ", Concat(myself.GetParameterString(parameters), myself.GenerateParameterListTail(parameters.GetParameterTail())));
        }

        return "";
    }

    function string GenerateParameterList(S84.CTCode.dbnf.ctcode.ParameterListDef parameters) {
        if (parameters) {
            return Concat(myself.GetParameterString(parameters), myself.GenerateParameterListTail(parameters.GetParameterTail()));
        } else {
            return "";
        }
    }

    function string GenerateCallingParameterList(S84.CTCode.dbnf.ctcode.ParameterList parameters) {
        if (parameters) {
            return Concat(myself.GetCallingParameterString(parameters), myself.GenerateCallingParameterListTail(parameters.GetParameterTail()));
        } else {
            return "";
        }
    }

    function string GetCallingParameterString(S84.CTCode.dbnf.ctcode.ParameterList parameter) {
        if (parameter) {
            return myself.GetRValueString(parameter.GetRValue());
        }
        else {
            return "";
        }
    }

    function string GenerateCallingParameterListTail(S84.CTCode.dbnf.ctcode.ParameterList parameters) {
        if (parameters) {
            return Concat(", ", Concat(myself.GetCallingParameterString(parameters), myself.GenerateCallingParameterListTail(parameters.GetParameterTail())));
        }

        return "";
    }

    function string GetType(S84.CTCode.dbnf.ctcode.ValueType value_type) {
        if (value_type.GetDimensionalType()) {
            return myself.GetDimensionalType(value_type.GetDimensionalType());
        }

        if (value_type.GetMapType()) {
            return myself.GetMapType(value_type.GetMapType());
        }

        if (value_type.GetSingletonType()) {
            return myself.GetSingletonType(value_type.GetSingletonType());
        }

        return "/*WARNING ValueType FALL THROUGH*/";
    }

    function string GetDimensionalType(S84.CTCode.dbnf.ctcode.DimensionalType dimensional_type) {
        S84.CTCode.dbnf.ctcode.DimensionalNote[] dimensional_note_list;
        dimensional_note_list = dimensional_type.GetDimensionalNote();
        int dimensionalNotes;
        dimensionalNotes = Size(dimensional_note_list);
        return Concat(myself.GetDimensionalPrefix(dimensionalNotes), Concat(myself.GetSingletonType(dimensional_type.GetSingletonType()), myself.GetDimensionalSuffix(dimensionalNotes)));
    }

    function string GetDimensionalPrefix(int dimensionalNotes) {
        string dimensionalPrefix;
        dimensionalPrefix = "";

        while (dimensionalNotes > 0) {
            dimensionalPrefix = Concat(dimensionalPrefix, "std::vector<");
            dimensionalNotes = dimensionalNotes - 1;
        }

        return dimensionalPrefix;
    }

    function string GetDimensionalSuffix(int dimensionalNotes) {
        string dimensionalSuffix;
        dimensionalSuffix = "";

        while (dimensionalNotes > 0) {
            dimensionalSuffix = Concat(dimensionalSuffix, ">");
            dimensionalNotes = dimensionalNotes - 1;
        }

        return dimensionalSuffix;
    }

    function string GetMapType(S84.CTCode.dbnf.ctcode.MapType map_type) {
        return Concat("std::unordered_map<std::string, ", Concat(myself.GetSingletonType(map_type.GetSingletonType()), ">"));
    }

    function string GetSingletonType(S84.CTCode.dbnf.ctcode.SingletonType singleton_type) {
        if (singleton_type.GetDefinedType()) {
            S84.CTCode.dbnf.ctcode.DefinedType defined_type;
            defined_type = singleton_type.GetDefinedType();
            S84.CTCode.dbnf.ctcode.QualfiedName defined_type_name;
            defined_type_name = defined_type.GetName();
            return myself.GetDefinedType(defined_type_name);
        }

        if (singleton_type.GetPrimativeType()) {
            S84.CTCode.dbnf.ctcode.PrimativeType primative_type;
            primative_type = singleton_type.GetPrimativeType();
            string primative_type_string;
            primative_type_string = primative_type.UnParse();

            if (primative_type_string == "int") {
                return "int";
            }

            if (primative_type_string == "string") {
                return "std::string";
            }

            if (primative_type_string == "bool") {
                return "bool";
            }

            if (primative_type_string == "float") {
                return "float";
            }

            if (primative_type_string == "void") {
                return "void";
            }

            return "/*WARNING PrimativeType FALL THROUGH*/";
        }

        return "/*WARNING SingletonType FALL THROUGH*/";
    }

    function string GetDefinedType(S84.CTCode.dbnf.ctcode.QualfiedName qualified_name) {
        string raw_type = myself.GetRawDefinedType(qualified_name);

        if (myself.IsUnmanagedType(raw_type)) {
            return Concat(raw_type, "*");
        } else {
            return Concat("OmniPointer<", Concat(raw_type, ">"));
        }
    }

    function string GetRawDefinedType(S84.CTCode.dbnf.ctcode.QualfiedName qualified_name) {
        S84.CTCode.dbnf.ctcode.NameTail name_tail;
        name_tail = qualified_name.GetTail();
        S84.CTCode.dbnf.ctcode.Name name;
        name = qualified_name.GetName();
        string result;
        result = "";

        if (name_tail)
        {
            string name_string;
            name_string = name.UnParse();
            string lower_name_string;
            lower_name_string = myself.ToLower(name_string);
            string name_tail_string;
            name_tail_string = myself.GetRawDefinedTypeTail(name_tail);
            result = Concat(result, lower_name_string);
            result = Concat(result, name_tail_string);
        } else {
            string class_name;
            class_name = myself.GenerateClassName(name);
            result = Concat(result, class_name);
        }

       return result;
    }

    function string GetRawDefinedTypeTail(S84.CTCode.dbnf.ctcode.NameTail name_tail)
    {
        S84.CTCode.dbnf.ctcode.NameTail name_tail_tail;
        name_tail_tail = name_tail.GetTail();
        S84.CTCode.dbnf.ctcode.Name name;
        name = name_tail.GetName();
        string result;
        result = "::";

        if (name_tail_tail)
        {
            string name_string;
            name_string = name.UnParse();
            string lower_name_string;
            lower_name_string = myself.ToLower(name_string);
            string name_tail_tail_string;
            name_tail_tail_string = myself.GetRawDefinedTypeTail(name_tail_tail);
            result = Concat(result, lower_name_string);
            result = Concat(result, name_tail_tail_string);
        } else {
            string class_name;
            class_name = myself.GenerateClassName(name);
            result = Concat(result, class_name);
        }

       return result;
    }

    function string GenerateClassName(S84.CTCode.dbnf.ctcode.Name name_node)
    {
        if (name_node)
        {
            string name_node_string = name_node.UnParse();
            return myself.SnakeCaseToCamelCase(name_node_string);
        }
        else
        {
            return "";
        }
    }

    function string GenerateVariableChainNameTail(S84.CTCode.dbnf.ctcode.NameTail name_tail)
    {
        if (name_tail.GetTail()) {
            return Concat(Concat(myself.GenerateVariableName(name_tail.GetName()), "->"), myself.GenerateVariableChainNameTail(name_tail.GetTail()));
        } else {
            return myself.GenerateVariableName(name_tail.GetName());
        }
    }

    function string GenerateVariableChain(S84.CTCode.dbnf.ctcode.QualfiedName qualified_name_node)
    {
        if (qualified_name_node.GetTail()) {
            return Concat(Concat(myself.GenerateVariableName(qualified_name_node.GetName()), "->"), myself.GenerateVariableChainNameTail(qualified_name_node.GetTail()));
        } else {
            return myself.GenerateVariableName(qualified_name_node.GetName());
        }
    }

    function string GenerateVariableName(S84.CTCode.dbnf.ctcode.Name name_node)
    {
        if (name_node)
        {
            string name_node_string = name_node.UnParse();

            if (name_node_string == "myself") {
                return "this";
            }

            return myself.CamelCaseToSnakeCase(name_node_string);
        }
        else
        {
            return "";
        }
    }

    function string GenerateCallName(S84.CTCode.dbnf.ctcode.Name name_node)
    {
        if (name_node)
        {
            string name_node_string = name_node.UnParse();
            return myself.SnakeCaseToCamelCase(name_node_string);
        }
        else
        {
            return "";
        }
    }

    function string[] TokenizeBaseName(string name)
    {
        string[] base_name_tokens;
        string current_token;
        current_token = "";
        int index;
        index = 0;

        while (index < Length(name)) {
            string character;
            character = At(name, index);

            if (character == ".") {
                Append(base_name_tokens, current_token);
                current_token = "";
            } else {
                current_token = Concat(current_token, character);
            }

            index = index + 1;
        }

        return base_name_tokens;
    }

    function string GenerateGuardName(string[] base_name_tokens)
    {
        string guard_name;
        guard_name = "";
        string ctcode_guard;
        ctcode_guard = "CTCODE_H";
        string namespace_seperator;
        namespace_seperator = "_";
        int index;
        index = 0;

        while (index < Size(base_name_tokens)) {
            string namespace_token;
            namespace_token = Element(base_name_tokens, index);
            string upper_namespace_token;
            upper_namespace_token = myself.ToUpper(namespace_token);
            guard_name = Concat(guard_name, upper_namespace_token);
            guard_name = Concat(guard_name, namespace_seperator);
            index = index + 1;
        }

        guard_name = Concat(guard_name, ctcode_guard);
        return guard_name;
    }

    function string SnakeCaseToCamelCase(string snake_case)
    {
        bool capitalize_this_letter;
        capitalize_this_letter = true;
        string camel_case;
        camel_case = "";
        int index;
        index = 0;

        while (index < Length(snake_case)) {
            string source_character;
            source_character = At(snake_case, index);

            if (source_character == "_") {
                capitalize_this_letter = true;
            } else {
                if (capitalize_this_letter == true)
                {
                    string upper_character;
                    upper_character = myself.CharacterToUpper(source_character);
                    capitalize_this_letter = false;
                    camel_case = Concat(camel_case, upper_character);
                } else {
                    capitalize_this_letter = false;
                    camel_case = Concat(camel_case, source_character);
                }
            }

            index = index + 1;
        }

        return camel_case;
    }

    function string CamelCaseToSnakeCase(string camel_case) {
        string delimiter;
        delimiter = "_";
        bool in_abbreviation;
        in_abbreviation = true;
        string snake_case;
        snake_case = "";
        int index;
        index = 0;

        while (index < Length(camel_case)) {
            string source_character;
            source_character = At(camel_case, index);
            string lower_character;
            lower_character = myself.CharacterToLower(source_character);

            if (myself.IsUpper(source_character) || myself.IsDigit(source_character)) {
                bool is_first_character;
                is_first_character = Length(snake_case) == 0;

                if (!in_abbreviation && !is_first_character) {
                    snake_case = Concat(snake_case, delimiter);
                }

                snake_case = Concat(snake_case, lower_character);
                in_abbreviation = true;
            } else {
                if (source_character == delimiter) {
                    snake_case = Concat(snake_case, delimiter);
                    in_abbreviation = true;
                } else {
                    snake_case = Concat(snake_case, lower_character);
                    in_abbreviation = false;
                }
            }

            index = index + 1;
        }

        return snake_case;
    }

    function bool IsUpper(string character) {
        bool result;
        result = false;
        result = result || character == "A";
        result = result || character == "B";
        result = result || character == "C";
        result = result || character == "D";
        result = result || character == "E";
        result = result || character == "F";
        result = result || character == "G";
        result = result || character == "H";
        result = result || character == "I";
        result = result || character == "J";
        result = result || character == "K";
        result = result || character == "L";
        result = result || character == "M";
        result = result || character == "N";
        result = result || character == "O";
        result = result || character == "P";
        result = result || character == "Q";
        result = result || character == "R";
        result = result || character == "S";
        result = result || character == "T";
        result = result || character == "U";
        result = result || character == "V";
        result = result || character == "W";
        result = result || character == "X";
        result = result || character == "Y";
        result = result || character == "Z";
        return result;
    }

    function bool IsDigit(string character) {
        bool result;
        result = false;
        result = result || character == "0";
        result = result || character == "1";
        result = result || character == "2";
        result = result || character == "3";
        result = result || character == "4";
        result = result || character == "5";
        result = result || character == "6";
        result = result || character == "7";
        result = result || character == "8";
        result = result || character == "9";
        return result;
    }

    function string ToLower(string input) {
        int index;
        index = 0;
        string result;
        result = "";

        while (index < Length(input)) {
            string character;
            character = At(input, index);
            string lowerCharacter;
            lowerCharacter = myself.CharacterToLower(character);
            result = Concat(result, lowerCharacter);
            index = index + 1;
        }

        return result;
    }

    function string CharacterToLower(string input) {
        if (input == "A") {
            return "a";
        }

        if (input == "B") {
            return "b";
        }

        if (input == "C") {
            return "c";
        }

        if (input == "D") {
            return "d";
        }

        if (input == "E") {
            return "e";
        }

        if (input == "F") {
            return "f";
        }

        if (input == "G") {
            return "g";
        }

        if (input == "H") {
            return "h";
        }

        if (input == "I") {
            return "i";
        }

        if (input == "J") {
            return "j";
        }

        if (input == "K") {
            return "k";
        }

        if (input == "L") {
            return "l";
        }

        if (input == "M") {
            return "m";
        }

        if (input == "N") {
            return "n";
        }

        if (input == "O") {
            return "o";
        }

        if (input == "P") {
            return "p";
        }

        if (input == "Q") {
            return "q";
        }

        if (input == "R") {
            return "r";
        }

        if (input == "S") {
            return "s";
        }

        if (input == "T") {
            return "t";
        }

        if (input == "U") {
            return "u";
        }

        if (input == "V") {
            return "v";
        }

        if (input == "W") {
            return "w";
        }

        if (input == "X") {
            return "x";
        }

        if (input == "Y") {
            return "y";
        }

        if (input == "Z") {
            return "z";
        }

        return input;
    }

    function string ToUpper(string input) {
        int index;
        index = 0;
        string result;
        result = "";

        while (index < Length(input)) {
            string character;
            character = At(input, index);
            string upperCharacter;
            upperCharacter = myself.CharacterToUpper(character);
            result = Concat(result, upperCharacter);
            index = index + 1;
        }

        return result;
    }

    function string CharacterToUpper(string input) {
        if (input == "a") {
            return "A";
        }

        if (input == "b") {
            return "B";
        }

        if (input == "c") {
            return "C";
        }

        if (input == "d") {
            return "D";
        }

        if (input == "e") {
            return "E";
        }

        if (input == "f") {
            return "F";
        }

        if (input == "g") {
            return "G";
        }

        if (input == "h") {
            return "H";
        }

        if (input == "i") {
            return "I";
        }

        if (input == "j") {
            return "J";
        }

        if (input == "k") {
            return "K";
        }

        if (input == "l") {
            return "L";
        }

        if (input == "m") {
            return "M";
        }

        if (input == "n") {
            return "N";
        }

        if (input == "o") {
            return "O";
        }

        if (input == "p") {
            return "P";
        }

        if (input == "q") {
            return "Q";
        }

        if (input == "r") {
            return "R";
        }

        if (input == "s") {
            return "S";
        }

        if (input == "t") {
            return "T";
        }

        if (input == "u") {
            return "U";
        }

        if (input == "v") {
            return "V";
        }

        if (input == "w") {
            return "W";
        }

        if (input == "x") {
            return "X";
        }

        if (input == "y") {
            return "Y";
        }

        if (input == "z") {
            return "Z";
        }

        return input;
    }
}